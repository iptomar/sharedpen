<html><head><script type="text/javascript">/*!
 * jQuery JavaScript Library v1.11.2
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-12-17T15:27Z
 */

(function( global, factory ) {

	if ( typeof module === "object" && typeof module.exports === "object" ) {
		// For CommonJS and CommonJS-like environments where a proper window is present,
		// execute the factory and get jQuery
		// For environments that do not inherently posses a window with a document
		// (such as Node.js), expose a jQuery-making factory as module.exports
		// This accentuates the need for the creation of a real window
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Can't do this because several apps including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
// Support: Firefox 18+
//

var deletedIds = [];

var slice = deletedIds.slice;

var concat = deletedIds.concat;

var push = deletedIds.push;

var indexOf = deletedIds.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var support = {};



var
	version = "1.11.2",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android<4.1, IE<9
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([\da-z])/gi,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {
	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// Start with an empty selector
	selector: "",

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num != null ?

			// Return just the one element from the set
			( num < 0 ? this[ num + this.length ] : this[ num ] ) :

			// Return all the elements in a clean array
			slice.call( this );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;
		ret.context = this.context;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: deletedIds.sort,
	splice: deletedIds.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var src, copyIsArray, copy, name, options, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	// See test/unit/core.js for details concerning isFunction.
	// Since version 1.3, DOM methods and functions like alert
	// aren't supported. They return false on IE (#2968).
	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray || function( obj ) {
		return jQuery.type(obj) === "array";
	},

	isWindow: function( obj ) {
		/* jshint eqeqeq: false */
		return obj != null && obj == obj.window;
	},

	isNumeric: function( obj ) {
		// parseFloat NaNs numeric-cast false positives (null|true|false|"")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		// adding 1 corrects loss of precision from parseFloat (#15100)
		return !jQuery.isArray( obj ) && (obj - parseFloat( obj ) + 1) >= 0;
	},

	isEmptyObject: function( obj ) {
		var name;
		for ( name in obj ) {
			return false;
		}
		return true;
	},

	isPlainObject: function( obj ) {
		var key;

		// Must be an Object.
		// Because of IE, we also have to check the presence of the constructor property.
		// Make sure that DOM nodes and window objects don't pass through, as well
		if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		try {
			// Not own constructor property must be Object
			if ( obj.constructor &&
				!hasOwn.call(obj, "constructor") &&
				!hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
				return false;
			}
		} catch ( e ) {
			// IE8,9 Will throw exceptions on certain host objects #9897
			return false;
		}

		// Support: IE<9
		// Handle iteration over inherited properties before own properties.
		if ( support.ownLast ) {
			for ( key in obj ) {
				return hasOwn.call( obj, key );
			}
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.
		for ( key in obj ) {}

		return key === undefined || hasOwn.call( obj, key );
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call(obj) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	// Workarounds based on findings by Jim Driscoll
	// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
	globalEval: function( data ) {
		if ( data && jQuery.trim( data ) ) {
			// We use execScript on Internet Explorer
			// We use an anonymous function so that context is window
			// rather than jQuery in Firefox
			( window.execScript || function( data ) {
				window[ "eval" ].call( window, data );
			} )( data );
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	// args is for internal usage only
	each: function( obj, callback, args ) {
		var value,
			i = 0,
			length = obj.length,
			isArray = isArraylike( obj );

		if ( args ) {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			}
		}

		return obj;
	},

	// Support: Android<4.1, IE<9
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArraylike( Object(arr) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		var len;

		if ( arr ) {
			if ( indexOf ) {
				return indexOf.call( arr, elem, i );
			}

			len = arr.length;
			i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

			for ( ; i < len; i++ ) {
				// Skip accessing in sparse arrays
				if ( i in arr && arr[ i ] === elem ) {
					return i;
				}
			}
		}

		return -1;
	},

	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		while ( j < len ) {
			first[ i++ ] = second[ j++ ];
		}

		// Support: IE<9
		// Workaround casting of .length to NaN on otherwise arraylike objects (e.g., NodeLists)
		if ( len !== len ) {
			while ( second[j] !== undefined ) {
				first[ i++ ] = second[ j++ ];
			}
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value,
			i = 0,
			length = elems.length,
			isArray = isArraylike( elems ),
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var args, proxy, tmp;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: function() {
		return +( new Date() );
	},

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

function isArraylike( obj ) {
	var length = obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	if ( obj.nodeType === 1 && length ) {
		return true;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.2.0-pre
 * http://sizzlejs.com/
 *
 * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-12-16
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// General-purpose constants
	MAX_NEGATIVE = 1 << 31,

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// http://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",
	// http://www.w3.org/TR/css3-syntax/#characters
	characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

	// Loosely modeled on CSS identifier characters
	// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
	// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = characterEncoding.replace( "w", "w#" ),

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + characterEncoding + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + characterEncoding + ")" ),
		"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
		"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,
	rescape = /'|\\/g,

	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	};

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var match, elem, m, nodeType,
		// QSA vars
		i, groups, old, nid, newContext, newSelector;

	if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
		setDocument( context );
	}

	context = context || document;
	results = results || [];
	nodeType = context.nodeType;

	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	if ( !seed && documentIsHTML ) {

		// Try to shortcut find operations when possible (e.g., not under DocumentFragment)
		if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {
			// Speed-up: Sizzle("#ID")
			if ( (m = match[1]) ) {
				if ( nodeType === 9 ) {
					elem = context.getElementById( m );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document (jQuery #6963)
					if ( elem && elem.parentNode ) {
						// Handle the case where IE, Opera, and Webkit return items
						// by name instead of ID
						if ( elem.id === m ) {
							results.push( elem );
							return results;
						}
					} else {
						return results;
					}
				} else {
					// Context is not a document
					if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
						contains( context, elem ) && elem.id === m ) {
						results.push( elem );
						return results;
					}
				}

			// Speed-up: Sizzle("TAG")
			} else if ( match[2] ) {
				push.apply( results, context.getElementsByTagName( selector ) );
				return results;

			// Speed-up: Sizzle(".CLASS")
			} else if ( (m = match[3]) && support.getElementsByClassName ) {
				push.apply( results, context.getElementsByClassName( m ) );
				return results;
			}
		}

		// QSA path
		if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
			nid = old = expando;
			newContext = context;
			newSelector = nodeType !== 1 && selector;

			// qSA works strangely on Element-rooted queries
			// We can work around this by specifying an extra ID on the root
			// and working up from there (Thanks to Andrew Dupont for the technique)
			// IE 8 doesn't work on object elements
			if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
				groups = tokenize( selector );

				if ( (old = context.getAttribute("id")) ) {
					nid = old.replace( rescape, "\\$&" );
				} else {
					context.setAttribute( "id", nid );
				}
				nid = "[id='" + nid + "'] ";

				i = groups.length;
				while ( i-- ) {
					groups[i] = nid + toSelector( groups[i] );
				}
				newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
				newSelector = groups.join(",");
			}

			if ( newSelector ) {
				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch(qsaError) {
				} finally {
					if ( !old ) {
						context.removeAttribute("id");
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
function assert( fn ) {
	var div = document.createElement("div");

	try {
		return !!fn( div );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( div.parentNode ) {
			div.parentNode.removeChild( div );
		}
		// release memory in IE
		div = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = attrs.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			( ~b.sourceIndex || MAX_NEGATIVE ) -
			( ~a.sourceIndex || MAX_NEGATIVE );

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, parent,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// If no document and documentElement is available, return
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Set our document
	document = doc;
	docElem = doc.documentElement;
	parent = doc.defaultView;

	// Support: IE>8
	// If iframe document is assigned to "document" variable and if iframe has been reloaded,
	// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
	// IE6-8 do not support the defaultView property so parent will be undefined
	if ( parent && parent !== parent.top ) {
		// IE11 does not have attachEvent, so all must suffer
		if ( parent.addEventListener ) {
			parent.addEventListener( "unload", unloadHandler, false );
		} else if ( parent.attachEvent ) {
			parent.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Support tests
	---------------------------------------------------------------------- */
	documentIsHTML = !isXML( doc );

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( div ) {
		div.className = "i";
		return !div.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( div ) {
		div.appendChild( doc.createComment("") );
		return !div.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( doc.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( div ) {
		docElem.appendChild( div ).id = expando;
		return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
	});

	// ID find and filter
	if ( support.getById ) {
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var m = context.getElementById( id );
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [ m ] : [];
			}
		};
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
	} else {
		// Support: IE6/7
		// getElementById is not reliable as a find shortcut
		delete Expr.find["ID"];

		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See http://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// http://bugs.jquery.com/ticket/12359
			docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\f]' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( div.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !div.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+
			if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibing-combinator selector` fails
			if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( div ) {
			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = doc.createElement("input");
			input.setAttribute( "type", "hidden" );
			div.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( div.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":enabled").length ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			div.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( div ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( div, "div" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( div, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully does not implement inclusive descendent
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === doc ? -1 :
				b === doc ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return doc;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, outerCache, node, diff, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {
							// Seek `elem` from a previously-cached index
							outerCache = parent[ expando ] || (parent[ expando ] = {});
							cache = outerCache[ type ] || [];
							nodeIndex = cache[0] === dirruns && cache[1];
							diff = cache[0] === dirruns && cache[2];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						// Use previously-cached element index if available
						} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
							diff = cache[1];

						// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
						} else {
							// Use the same loop as above to seek `elem` from the start
							while ( (node = ++nodeIndex && node && node[ dir ] ||
								(diff = nodeIndex = 0) || start.pop()) ) {

								if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
									// Cache the index of each encountered element
									if ( useCache ) {
										(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
									}

									if ( node === elem ) {
										break;
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": function( elem ) {
			return elem.disabled === false;
		},

		"disabled": function( elem ) {
			return elem.disabled === true;
		},

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		checkNonElements = base && dir === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});
						if ( (oldCache = outerCache[ dir ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							outerCache[ dir ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context !== document && context;
			}

			// Add elements passing elementMatchers directly to results
			// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// Apply set filters to unmatched elements
			matchedCount += i;
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is no seed and only one group
	if ( match.length === 1 ) {

		// Take a shortcut and set the context if the root selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				support.getById && context.nodeType === 9 && documentIsHTML &&
				Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( div1 ) {
	// Should return 1, but returns 4 (following)
	return div1.compareDocumentPosition( document.createElement("div") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( div ) {
	div.innerHTML = "<a href='#'></a>";
	return div.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( div ) {
	div.innerHTML = "<input/>";
	div.firstChild.setAttribute( "value", "" );
	return div.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( div ) {
	return div.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.pseudos;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;



var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			/* jshint -W018 */
			return !!qualifier.call( elem, i, elem ) !== not;
		});

	}

	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		});

	}

	if ( typeof qualifier === "string" ) {
		if ( risSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}

		qualifier = jQuery.filter( qualifier, elements );
	}

	return jQuery.grep( elements, function( elem ) {
		return ( jQuery.inArray( elem, qualifier ) >= 0 ) !== not;
	});
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	return elems.length === 1 && elem.nodeType === 1 ?
		jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
		jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		}));
};

jQuery.fn.extend({
	find: function( selector ) {
		var i,
			ret = [],
			self = this,
			len = self.length;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter(function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			}) );
		}

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		// Needed because $( selector, context ) becomes $( context ).find( selector )
		ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
		ret.selector = this.selector ? this.selector + " " + selector : selector;
		return ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow(this, selector || [], false) );
	},
	not: function( selector ) {
		return this.pushStack( winnow(this, selector || [], true) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
});


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// Use the correct document accordingly with window argument (sandbox)
	document = window.document,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

	init = jQuery.fn.init = function( selector, context ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;

					// scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[1],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {
							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[2] );

					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Handle the case where IE and Opera return items
						// by name instead of ID
						if ( elem.id !== match[2] ) {
							return rootjQuery.find( selector );
						}

						// Otherwise, we inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return typeof rootjQuery.ready !== "undefined" ?
				rootjQuery.ready( selector ) :
				// Execute immediately if ready is not present
				selector( jQuery );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,
	// methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.extend({
	dir: function( elem, dir, until ) {
		var matched = [],
			cur = elem[ dir ];

		while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
			if ( cur.nodeType === 1 ) {
				matched.push( cur );
			}
			cur = cur[dir];
		}
		return matched;
	},

	sibling: function( n, elem ) {
		var r = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				r.push( n );
			}
		}

		return r;
	}
});

jQuery.fn.extend({
	has: function( target ) {
		var i,
			targets = jQuery( target, this ),
			len = targets.length;

		return this.filter(function() {
			for ( i = 0; i < len; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( ; i < l; i++ ) {
			for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
				// Always skip document fragments
				if ( cur.nodeType < 11 && (pos ?
					pos.index(cur) > -1 :

					// Don't pass non-elements to Sizzle
					cur.nodeType === 1 &&
						jQuery.find.matchesSelector(cur, selectors)) ) {

					matched.push( cur );
					break;
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
	},

	// Determine the position of an element within
	// the matched set of elements
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[0] && this[0].parentNode ) ? this.first().prevAll().length : -1;
		}

		// index in selector
		if ( typeof elem === "string" ) {
			return jQuery.inArray( this[0], jQuery( elem ) );
		}

		// Locate the position of the desired element
		return jQuery.inArray(
			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[0] : elem, this );
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.unique(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter(selector)
		);
	}
});

function sibling( cur, dir ) {
	do {
		cur = cur[ dir ];
	} while ( cur && cur.nodeType !== 1 );

	return cur;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return jQuery.nodeName( elem, "iframe" ) ?
			elem.contentDocument || elem.contentWindow.document :
			jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var ret = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			ret = jQuery.filter( selector, ret );
		}

		if ( this.length > 1 ) {
			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				ret = jQuery.unique( ret );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				ret = ret.reverse();
			}
		}

		return this.pushStack( ret );
	};
});
var rnotwhite = (/\S+/g);



// String to Object options format cache
var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
function createOptions( options ) {
	var object = optionsCache[ options ] = {};
	jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	});
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		( optionsCache[ options ] || createOptions( options ) ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,
		// Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list was already fired
		fired,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = !options.once && [],
		// Fire callbacks
		fire = function( data ) {
			memory = options.memory && data;
			fired = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			firing = true;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
					memory = false; // To prevent further calls using add
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( stack ) {
					if ( stack.length ) {
						fire( stack.shift() );
					}
				} else if ( memory ) {
					list = [];
				} else {
					self.disable();
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					// First, we save the current length
					var start = list.length;
					(function add( args ) {
						jQuery.each( args, function( _, arg ) {
							var type = jQuery.type( arg );
							if ( type === "function" ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && type !== "string" ) {
								// Inspect recursively
								add( arg );
							}
						});
					})( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away
					} else if ( memory ) {
						firingStart = start;
						fire( memory );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
							// Handle firing indexes
							if ( firing ) {
								if ( index <= firingLength ) {
									firingLength--;
								}
								if ( index <= firingIndex ) {
									firingIndex--;
								}
							}
						}
					});
				}
				return this;
			},
			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				firingLength = 0;
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( list && ( !fired || stack ) ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					if ( firing ) {
						stack.push( args );
					} else {
						fire( args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


jQuery.extend({

	Deferred: function( func ) {
		var tuples = [
				// action, add listener, listener list, final state
				[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
				[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
				[ "notify", "progress", jQuery.Callbacks("memory") ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[ tuple[1] ](function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.done( newDefer.resolve )
										.fail( newDefer.reject )
										.progress( newDefer.notify );
								} else {
									newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
								}
							});
						});
						fns = null;
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			// promise[ done | fail | progress ] = list.add
			promise[ tuple[1] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(function() {
					// state = [ resolved | rejected ]
					state = stateString;

				// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			// deferred[ resolve | reject | notify ]
			deferred[ tuple[0] ] = function() {
				deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
				return this;
			};
			deferred[ tuple[0] + "With" ] = list.fireWith;
		});

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( values === progressValues ) {
						deferred.notifyWith( contexts, values );

					} else if ( !(--remaining) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject )
						.progress( updateFunc( i, progressContexts, progressValues ) );
				} else {
					--remaining;
				}
			}
		}

		// if we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
});


// The deferred used on DOM ready
var readyList;

jQuery.fn.ready = function( fn ) {
	// Add the callback
	jQuery.ready.promise().done( fn );

	return this;
};

jQuery.extend({
	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
		if ( !document.body ) {
			return setTimeout( jQuery.ready );
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );

		// Trigger any bound ready events
		if ( jQuery.fn.triggerHandler ) {
			jQuery( document ).triggerHandler( "ready" );
			jQuery( document ).off( "ready" );
		}
	}
});

/**
 * Clean-up method for dom ready events
 */
function detach() {
	if ( document.addEventListener ) {
		document.removeEventListener( "DOMContentLoaded", completed, false );
		window.removeEventListener( "load", completed, false );

	} else {
		document.detachEvent( "onreadystatechange", completed );
		window.detachEvent( "onload", completed );
	}
}

/**
 * The ready event handler and self cleanup method
 */
function completed() {
	// readyState === "complete" is good enough for us to call the dom ready in oldIE
	if ( document.addEventListener || event.type === "load" || document.readyState === "complete" ) {
		detach();
		jQuery.ready();
	}
}

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		// Catch cases where $(document).ready() is called after the browser event has already occurred.
		// we once tried to use readyState "interactive" here, but it caused issues like the one
		// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			setTimeout( jQuery.ready );

		// Standards-based browsers support DOMContentLoaded
		} else if ( document.addEventListener ) {
			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", completed, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", completed, false );

		// If IE event model is used
		} else {
			// Ensure firing before onload, maybe late but safe also for iframes
			document.attachEvent( "onreadystatechange", completed );

			// A fallback to window.onload, that will always work
			window.attachEvent( "onload", completed );

			// If IE and not a frame
			// continually check to see if the document is ready
			var top = false;

			try {
				top = window.frameElement == null && document.documentElement;
			} catch(e) {}

			if ( top && top.doScroll ) {
				(function doScrollCheck() {
					if ( !jQuery.isReady ) {

						try {
							// Use the trick by Diego Perini
							// http://javascript.nwbox.com/IEContentLoaded/
							top.doScroll("left");
						} catch(e) {
							return setTimeout( doScrollCheck, 50 );
						}

						// detach all dom ready events
						detach();

						// and execute any waiting functions
						jQuery.ready();
					}
				})();
			}
		}
	}
	return readyList.promise( obj );
};


var strundefined = typeof undefined;



// Support: IE<9
// Iteration over object's inherited properties before its own
var i;
for ( i in jQuery( support ) ) {
	break;
}
support.ownLast = i !== "0";

// Note: most support tests are defined in their respective modules.
// false until the test is run
support.inlineBlockNeedsLayout = false;

// Execute ASAP in case we need to set body.style.zoom
jQuery(function() {
	// Minified: var a,b,c,d
	var val, div, body, container;

	body = document.getElementsByTagName( "body" )[ 0 ];
	if ( !body || !body.style ) {
		// Return for frameset docs that don't have a body
		return;
	}

	// Setup
	div = document.createElement( "div" );
	container = document.createElement( "div" );
	container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
	body.appendChild( container ).appendChild( div );

	if ( typeof div.style.zoom !== strundefined ) {
		// Support: IE<8
		// Check if natively block-level elements act like inline-block
		// elements when setting their display to 'inline' and giving
		// them layout
		div.style.cssText = "display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1";

		support.inlineBlockNeedsLayout = val = div.offsetWidth === 3;
		if ( val ) {
			// Prevent IE 6 from affecting layout for positioned elements #11048
			// Prevent IE from shrinking the body in IE 7 mode #12869
			// Support: IE<8
			body.style.zoom = 1;
		}
	}

	body.removeChild( container );
});




(function() {
	var div = document.createElement( "div" );

	// Execute the test only if not already executed in another module.
	if (support.deleteExpando == null) {
		// Support: IE<9
		support.deleteExpando = true;
		try {
			delete div.test;
		} catch( e ) {
			support.deleteExpando = false;
		}
	}

	// Null elements to avoid leaks in IE.
	div = null;
})();


/**
 * Determines whether an object can have data
 */
jQuery.acceptData = function( elem ) {
	var noData = jQuery.noData[ (elem.nodeName + " ").toLowerCase() ],
		nodeType = +elem.nodeType || 1;

	// Do not set data on non-element DOM nodes because it will not be cleared (#8335).
	return nodeType !== 1 && nodeType !== 9 ?
		false :

		// Nodes accept data unless otherwise specified; rejection can be conditional
		!noData || noData !== true && elem.getAttribute("classid") === noData;
};


var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /([A-Z])/g;

function dataAttr( elem, key, data ) {
	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {

		var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();

		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
					data === "false" ? false :
					data === "null" ? null :
					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			jQuery.data( elem, key, data );

		} else {
			data = undefined;
		}
	}

	return data;
}

// checks a cache object for emptiness
function isEmptyDataObject( obj ) {
	var name;
	for ( name in obj ) {

		// if the public data object is empty, the private is still empty
		if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
			continue;
		}
		if ( name !== "toJSON" ) {
			return false;
		}
	}

	return true;
}

function internalData( elem, name, data, pvt /* Internal Use Only */ ) {
	if ( !jQuery.acceptData( elem ) ) {
		return;
	}

	var ret, thisCache,
		internalKey = jQuery.expando,

		// We have to handle DOM nodes and JS objects differently because IE6-7
		// can't GC object references properly across the DOM-JS boundary
		isNode = elem.nodeType,

		// Only DOM nodes need the global jQuery cache; JS object data is
		// attached directly to the object so GC can occur automatically
		cache = isNode ? jQuery.cache : elem,

		// Only defining an ID for JS objects if its cache already exists allows
		// the code to shortcut on the same path as a DOM node with no cache
		id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey;

	// Avoid doing any more work than we need to when trying to get data on an
	// object that has no data at all
	if ( (!id || !cache[id] || (!pvt && !cache[id].data)) && data === undefined && typeof name === "string" ) {
		return;
	}

	if ( !id ) {
		// Only DOM nodes need a new unique ID for each element since their data
		// ends up in the global cache
		if ( isNode ) {
			id = elem[ internalKey ] = deletedIds.pop() || jQuery.guid++;
		} else {
			id = internalKey;
		}
	}

	if ( !cache[ id ] ) {
		// Avoid exposing jQuery metadata on plain JS objects when the object
		// is serialized using JSON.stringify
		cache[ id ] = isNode ? {} : { toJSON: jQuery.noop };
	}

	// An object can be passed to jQuery.data instead of a key/value pair; this gets
	// shallow copied over onto the existing cache
	if ( typeof name === "object" || typeof name === "function" ) {
		if ( pvt ) {
			cache[ id ] = jQuery.extend( cache[ id ], name );
		} else {
			cache[ id ].data = jQuery.extend( cache[ id ].data, name );
		}
	}

	thisCache = cache[ id ];

	// jQuery data() is stored in a separate object inside the object's internal data
	// cache in order to avoid key collisions between internal data and user-defined
	// data.
	if ( !pvt ) {
		if ( !thisCache.data ) {
			thisCache.data = {};
		}

		thisCache = thisCache.data;
	}

	if ( data !== undefined ) {
		thisCache[ jQuery.camelCase( name ) ] = data;
	}

	// Check for both converted-to-camel and non-converted data property names
	// If a data property was specified
	if ( typeof name === "string" ) {

		// First Try to find as-is property data
		ret = thisCache[ name ];

		// Test for null|undefined property data
		if ( ret == null ) {

			// Try to find the camelCased property
			ret = thisCache[ jQuery.camelCase( name ) ];
		}
	} else {
		ret = thisCache;
	}

	return ret;
}

function internalRemoveData( elem, name, pvt ) {
	if ( !jQuery.acceptData( elem ) ) {
		return;
	}

	var thisCache, i,
		isNode = elem.nodeType,

		// See jQuery.data for more information
		cache = isNode ? jQuery.cache : elem,
		id = isNode ? elem[ jQuery.expando ] : jQuery.expando;

	// If there is already no cache entry for this object, there is no
	// purpose in continuing
	if ( !cache[ id ] ) {
		return;
	}

	if ( name ) {

		thisCache = pvt ? cache[ id ] : cache[ id ].data;

		if ( thisCache ) {

			// Support array or space separated string names for data keys
			if ( !jQuery.isArray( name ) ) {

				// try the string as a key before any manipulation
				if ( name in thisCache ) {
					name = [ name ];
				} else {

					// split the camel cased version by spaces unless a key with the spaces exists
					name = jQuery.camelCase( name );
					if ( name in thisCache ) {
						name = [ name ];
					} else {
						name = name.split(" ");
					}
				}
			} else {
				// If "name" is an array of keys...
				// When data is initially created, via ("key", "val") signature,
				// keys will be converted to camelCase.
				// Since there is no way to tell _how_ a key was added, remove
				// both plain key and camelCase key. #12786
				// This will only penalize the array argument path.
				name = name.concat( jQuery.map( name, jQuery.camelCase ) );
			}

			i = name.length;
			while ( i-- ) {
				delete thisCache[ name[i] ];
			}

			// If there is no data left in the cache, we want to continue
			// and let the cache object itself get destroyed
			if ( pvt ? !isEmptyDataObject(thisCache) : !jQuery.isEmptyObject(thisCache) ) {
				return;
			}
		}
	}

	// See jQuery.data for more information
	if ( !pvt ) {
		delete cache[ id ].data;

		// Don't destroy the parent cache unless the internal data object
		// had been the only thing left in it
		if ( !isEmptyDataObject( cache[ id ] ) ) {
			return;
		}
	}

	// Destroy the cache
	if ( isNode ) {
		jQuery.cleanData( [ elem ], true );

	// Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)
	/* jshint eqeqeq: false */
	} else if ( support.deleteExpando || cache != cache.window ) {
		/* jshint eqeqeq: true */
		delete cache[ id ];

	// When all else fails, null
	} else {
		cache[ id ] = null;
	}
}

jQuery.extend({
	cache: {},

	// The following elements (space-suffixed to avoid Object.prototype collisions)
	// throw uncatchable exceptions if you attempt to set expando properties
	noData: {
		"applet ": true,
		"embed ": true,
		// ...but Flash objects (which have this classid) *can* handle expandos
		"object ": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
	},

	hasData: function( elem ) {
		elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
		return !!elem && !isEmptyDataObject( elem );
	},

	data: function( elem, name, data ) {
		return internalData( elem, name, data );
	},

	removeData: function( elem, name ) {
		return internalRemoveData( elem, name );
	},

	// For internal use only.
	_data: function( elem, name, data ) {
		return internalData( elem, name, data, true );
	},

	_removeData: function( elem, name ) {
		return internalRemoveData( elem, name, true );
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var i, name, data,
			elem = this[0],
			attrs = elem && elem.attributes;

		// Special expections of .data basically thwart jQuery.access,
		// so implement the relevant behavior ourselves

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = jQuery.data( elem );

				if ( elem.nodeType === 1 && !jQuery._data( elem, "parsedAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE11+
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = jQuery.camelCase( name.slice(5) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					jQuery._data( elem, "parsedAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each(function() {
				jQuery.data( this, key );
			});
		}

		return arguments.length > 1 ?

			// Sets one value
			this.each(function() {
				jQuery.data( this, key, value );
			}) :

			// Gets one value
			// Try to fetch any internally stored data first
			elem ? dataAttr( elem, key, jQuery.data( elem, key ) ) : undefined;
	},

	removeData: function( key ) {
		return this.each(function() {
			jQuery.removeData( this, key );
		});
	}
});


jQuery.extend({
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = jQuery._data( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray(data) ) {
					queue = jQuery._data( elem, type, jQuery.makeArray(data) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// not intended for public consumption - generates a queueHooks object, or returns the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return jQuery._data( elem, key ) || jQuery._data( elem, key, {
			empty: jQuery.Callbacks("once memory").add(function() {
				jQuery._removeData( elem, type + "queue" );
				jQuery._removeData( elem, key );
			})
		});
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[0], type );
		}

		return data === undefined ?
			this :
			this.each(function() {
				var queue = jQuery.queue( this, type, data );

				// ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[0] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = jQuery._data( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
});
var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHidden = function( elem, el ) {
		// isHidden might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;
		return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
	};



// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		length = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {
			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < length; i++ ) {
				fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
			}
		}
	}

	return chainable ?
		elems :

		// Gets
		bulk ?
			fn.call( elems ) :
			length ? fn( elems[0], key ) : emptyGet;
};
var rcheckableType = (/^(?:checkbox|radio)$/i);



(function() {
	// Minified: var a,b,c
	var input = document.createElement( "input" ),
		div = document.createElement( "div" ),
		fragment = document.createDocumentFragment();

	// Setup
	div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";

	// IE strips leading whitespace when .innerHTML is used
	support.leadingWhitespace = div.firstChild.nodeType === 3;

	// Make sure that tbody elements aren't automatically inserted
	// IE will insert them into empty tables
	support.tbody = !div.getElementsByTagName( "tbody" ).length;

	// Make sure that link elements get serialized correctly by innerHTML
	// This requires a wrapper element in IE
	support.htmlSerialize = !!div.getElementsByTagName( "link" ).length;

	// Makes sure cloning an html5 element does not cause problems
	// Where outerHTML is undefined, this still works
	support.html5Clone =
		document.createElement( "nav" ).cloneNode( true ).outerHTML !== "<:nav></:nav>";

	// Check if a disconnected checkbox will retain its checked
	// value of true after appended to the DOM (IE6/7)
	input.type = "checkbox";
	input.checked = true;
	fragment.appendChild( input );
	support.appendChecked = input.checked;

	// Make sure textarea (and checkbox) defaultValue is properly cloned
	// Support: IE6-IE11+
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

	// #11217 - WebKit loses check when the name is after the checked attribute
	fragment.appendChild( div );
	div.innerHTML = "<input type='radio' checked='checked' name='t'/>";

	// Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3
	// old WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE<9
	// Opera does not clone events (and typeof div.attachEvent === undefined).
	// IE9-10 clones events bound via attachEvent, but they don't trigger with .click()
	support.noCloneEvent = true;
	if ( div.attachEvent ) {
		div.attachEvent( "onclick", function() {
			support.noCloneEvent = false;
		});

		div.cloneNode( true ).click();
	}

	// Execute the test only if not already executed in another module.
	if (support.deleteExpando == null) {
		// Support: IE<9
		support.deleteExpando = true;
		try {
			delete div.test;
		} catch( e ) {
			support.deleteExpando = false;
		}
	}
})();


(function() {
	var i, eventName,
		div = document.createElement( "div" );

	// Support: IE<9 (lack submit/change bubble), Firefox 23+ (lack focusin event)
	for ( i in { submit: true, change: true, focusin: true }) {
		eventName = "on" + i;

		if ( !(support[ i + "Bubbles" ] = eventName in window) ) {
			// Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP)
			div.setAttribute( eventName, "t" );
			support[ i + "Bubbles" ] = div.attributes[ eventName ].expando === false;
		}
	}

	// Null elements to avoid leaks in IE.
	div = null;
})();


var rformElems = /^(?:input|select|textarea)$/i,
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {
		var tmp, events, t, handleObjIn,
			special, eventHandle, handleObj,
			handlers, type, namespaces, origType,
			elemData = jQuery._data( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !(events = elemData.events) ) {
			events = elemData.events = {};
		}
		if ( !(eventHandle = elemData.handle) ) {
			eventHandle = elemData.handle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== strundefined && (!e || jQuery.event.triggered !== e.type) ?
					jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
					undefined;
			};
			// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
			eventHandle.elem = elem;
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !(handlers = events[ type ]) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener/attachEvent if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					// Bind the global event handler to the element
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );

					} else if ( elem.attachEvent ) {
						elem.attachEvent( "on" + type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

		// Nullify elem to prevent memory leaks in IE
		elem = null;
	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {
		var j, handleObj, tmp,
			origCount, t, events,
			special, handlers, type,
			namespaces, origType,
			elemData = jQuery.hasData( elem ) && jQuery._data( elem );

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			delete elemData.handle;

			// removeData also checks for emptiness and clears the expando if empty
			// so use it instead of delete
			jQuery._removeData( elem, "events" );
		}
	},

	trigger: function( event, data, elem, onlyHandlers ) {
		var handle, ontype, cur,
			bubbleType, special, tmp, i,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf(".") >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf(":") < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join(".");
		event.namespace_re = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === (elem.ownerDocument || document) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && jQuery.acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
				jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Can't use an .isFunction() check here because IE6/7 fails that test.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && elem[ type ] && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					try {
						elem[ type ]();
					} catch ( e ) {
						// IE<9 dies on focus/blur to hidden element (#1486,#12518)
						// only reproducible on winXP IE8 native, not IE9 in IE8 mode
					}
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event );

		var i, ret, handleObj, matched, j,
			handlerQueue = [],
			args = slice.call( arguments ),
			handlers = ( jQuery._data( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or
				// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( (event.result = ret) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var sel, handleObj, matches, i,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		// Black-hole SVG <use> instance trees (#13180)
		// Avoid non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

			/* jshint eqeqeq: false */
			for ( ; cur != this; cur = cur.parentNode || this ) {
				/* jshint eqeqeq: true */

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && (cur.disabled !== true || event.type !== "click") ) {
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matches[ sel ] === undefined ) {
							matches[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) >= 0 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matches[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push({ elem: cur, handlers: matches });
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( delegateCount < handlers.length ) {
			handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
		}

		return handlerQueue;
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop, copy,
			type = event.type,
			originalEvent = event,
			fixHook = this.fixHooks[ type ];

		if ( !fixHook ) {
			this.fixHooks[ type ] = fixHook =
				rmouseEvent.test( type ) ? this.mouseHooks :
				rkeyEvent.test( type ) ? this.keyHooks :
				{};
		}
		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = new jQuery.Event( originalEvent );

		i = copy.length;
		while ( i-- ) {
			prop = copy[ i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Support: IE<9
		// Fix target property (#1925)
		if ( !event.target ) {
			event.target = originalEvent.srcElement || document;
		}

		// Support: Chrome 23+, Safari?
		// Target should not be a text node (#504, #13143)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		// Support: IE<9
		// For mouse/key events, metaKey==false if it's undefined (#3368, #11328)
		event.metaKey = !!event.metaKey;

		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var body, eventDoc, doc,
				button = original.button,
				fromElement = original.fromElement;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add relatedTarget, if necessary
			if ( !event.relatedTarget && fromElement ) {
				event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	special: {
		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {
			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					try {
						this.focus();
						return false;
					} catch ( e ) {
						// Support: IE<9
						// If we error on focus to hidden element (#1486, #12518),
						// let .trigger() run the handlers
					}
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {
			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( jQuery.nodeName( this, "input" ) && this.type === "checkbox" && this.click ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return jQuery.nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

jQuery.removeEvent = document.removeEventListener ?
	function( elem, type, handle ) {
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle, false );
		}
	} :
	function( elem, type, handle ) {
		var name = "on" + type;

		if ( elem.detachEvent ) {

			// #8545, #7054, preventing memory leaks for custom events in IE6-8
			// detachEvent needed property on element, by name of that event, to properly expose it to GC
			if ( typeof elem[ name ] === strundefined ) {
				elem[ name ] = null;
			}

			elem.detachEvent( name, handle );
		}
	};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&
				// Support: IE < 9, Android < 4.0
				src.returnValue === false ?
			returnTrue :
			returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;
		if ( !e ) {
			return;
		}

		// If preventDefault exists, run it on the original event
		if ( e.preventDefault ) {
			e.preventDefault();

		// Support: IE
		// Otherwise set the returnValue property of the original event to false
		} else {
			e.returnValue = false;
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;
		if ( !e ) {
			return;
		}
		// If stopPropagation exists, run it on the original event
		if ( e.stopPropagation ) {
			e.stopPropagation();
		}

		// Support: IE
		// Set the cancelBubble property of the original event to true
		e.cancelBubble = true;
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && e.stopImmediatePropagation ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Create mouseenter/leave events using mouseover/out and event-time checks
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// IE submit delegation
if ( !support.submitBubbles ) {

	jQuery.event.special.submit = {
		setup: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Lazy-add a submit handler when a descendant form may potentially be submitted
			jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
				// Node name check avoids a VML-related crash in IE (#9807)
				var elem = e.target,
					form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
				if ( form && !jQuery._data( form, "submitBubbles" ) ) {
					jQuery.event.add( form, "submit._submit", function( event ) {
						event._submit_bubble = true;
					});
					jQuery._data( form, "submitBubbles", true );
				}
			});
			// return undefined since we don't need an event listener
		},

		postDispatch: function( event ) {
			// If form was submitted by the user, bubble the event up the tree
			if ( event._submit_bubble ) {
				delete event._submit_bubble;
				if ( this.parentNode && !event.isTrigger ) {
					jQuery.event.simulate( "submit", this.parentNode, event, true );
				}
			}
		},

		teardown: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Remove delegated handlers; cleanData eventually reaps submit handlers attached above
			jQuery.event.remove( this, "._submit" );
		}
	};
}

// IE change delegation and checkbox/radio fix
if ( !support.changeBubbles ) {

	jQuery.event.special.change = {

		setup: function() {

			if ( rformElems.test( this.nodeName ) ) {
				// IE doesn't fire change on a check/radio until blur; trigger it on click
				// after a propertychange. Eat the blur-change in special.change.handle.
				// This still fires onchange a second time for check/radio after blur.
				if ( this.type === "checkbox" || this.type === "radio" ) {
					jQuery.event.add( this, "propertychange._change", function( event ) {
						if ( event.originalEvent.propertyName === "checked" ) {
							this._just_changed = true;
						}
					});
					jQuery.event.add( this, "click._change", function( event ) {
						if ( this._just_changed && !event.isTrigger ) {
							this._just_changed = false;
						}
						// Allow triggered, simulated change events (#11500)
						jQuery.event.simulate( "change", this, event, true );
					});
				}
				return false;
			}
			// Delegated event; lazy-add a change handler on descendant inputs
			jQuery.event.add( this, "beforeactivate._change", function( e ) {
				var elem = e.target;

				if ( rformElems.test( elem.nodeName ) && !jQuery._data( elem, "changeBubbles" ) ) {
					jQuery.event.add( elem, "change._change", function( event ) {
						if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
							jQuery.event.simulate( "change", this.parentNode, event, true );
						}
					});
					jQuery._data( elem, "changeBubbles", true );
				}
			});
		},

		handle: function( event ) {
			var elem = event.target;

			// Swallow native change events from checkbox/radio, we already triggered them above
			if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
				return event.handleObj.handler.apply( this, arguments );
			}
		},

		teardown: function() {
			jQuery.event.remove( this, "._change" );

			return !rformElems.test( this.nodeName );
		}
	};
}

// Create "bubbling" focus and blur events
if ( !support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = jQuery._data( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				jQuery._data( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = jQuery._data( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					jQuery._removeData( doc, fix );
				} else {
					jQuery._data( doc, fix, attaches );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var type, origFn;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on( types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		var elem = this[0];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
});


function createSafeFragment( document ) {
	var list = nodeNames.split( "|" ),
		safeFrag = document.createDocumentFragment();

	if ( safeFrag.createElement ) {
		while ( list.length ) {
			safeFrag.createElement(
				list.pop()
			);
		}
	}
	return safeFrag;
}

var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +
		"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
	rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g,
	rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
	rleadingWhitespace = /^\s+/,
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
	rtagName = /<([\w:]+)/,
	rtbody = /<tbody/i,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style|link)/i,
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /^$|\/(?:java|ecma)script/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

	// We have to close these tags to support XHTML (#13200)
	wrapMap = {
		option: [ 1, "<select multiple='multiple'>", "</select>" ],
		legend: [ 1, "<fieldset>", "</fieldset>" ],
		area: [ 1, "<map>", "</map>" ],
		param: [ 1, "<object>", "</object>" ],
		thead: [ 1, "<table>", "</table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		// IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
		// unless wrapped in a div with non-breaking characters in front of it.
		_default: support.htmlSerialize ? [ 0, "", "" ] : [ 1, "X<div>", "</div>"  ]
	},
	safeFragment = createSafeFragment( document ),
	fragmentDiv = safeFragment.appendChild( document.createElement("div") );

wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

function getAll( context, tag ) {
	var elems, elem,
		i = 0,
		found = typeof context.getElementsByTagName !== strundefined ? context.getElementsByTagName( tag || "*" ) :
			typeof context.querySelectorAll !== strundefined ? context.querySelectorAll( tag || "*" ) :
			undefined;

	if ( !found ) {
		for ( found = [], elems = context.childNodes || context; (elem = elems[i]) != null; i++ ) {
			if ( !tag || jQuery.nodeName( elem, tag ) ) {
				found.push( elem );
			} else {
				jQuery.merge( found, getAll( elem, tag ) );
			}
		}
	}

	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
		jQuery.merge( [ context ], found ) :
		found;
}

// Used in buildFragment, fixes the defaultChecked property
function fixDefaultChecked( elem ) {
	if ( rcheckableType.test( elem.type ) ) {
		elem.defaultChecked = elem.checked;
	}
}

// Support: IE<8
// Manipulating tables requires a tbody
function manipulationTarget( elem, content ) {
	return jQuery.nodeName( elem, "table" ) &&
		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

		elem.getElementsByTagName("tbody")[0] ||
			elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
		elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = (jQuery.find.attr( elem, "type" ) !== null) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );
	if ( match ) {
		elem.type = match[1];
	} else {
		elem.removeAttribute("type");
	}
	return elem;
}

// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var elem,
		i = 0;
	for ( ; (elem = elems[i]) != null; i++ ) {
		jQuery._data( elem, "globalEval", !refElements || jQuery._data( refElements[i], "globalEval" ) );
	}
}

function cloneCopyEvent( src, dest ) {

	if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
		return;
	}

	var type, i, l,
		oldData = jQuery._data( src ),
		curData = jQuery._data( dest, oldData ),
		events = oldData.events;

	if ( events ) {
		delete curData.handle;
		curData.events = {};

		for ( type in events ) {
			for ( i = 0, l = events[ type ].length; i < l; i++ ) {
				jQuery.event.add( dest, type, events[ type ][ i ] );
			}
		}
	}

	// make the cloned public data object a copy from the original
	if ( curData.data ) {
		curData.data = jQuery.extend( {}, curData.data );
	}
}

function fixCloneNodeIssues( src, dest ) {
	var nodeName, e, data;

	// We do not need to do anything for non-Elements
	if ( dest.nodeType !== 1 ) {
		return;
	}

	nodeName = dest.nodeName.toLowerCase();

	// IE6-8 copies events bound via attachEvent when using cloneNode.
	if ( !support.noCloneEvent && dest[ jQuery.expando ] ) {
		data = jQuery._data( dest );

		for ( e in data.events ) {
			jQuery.removeEvent( dest, e, data.handle );
		}

		// Event data gets referenced instead of copied if the expando gets copied too
		dest.removeAttribute( jQuery.expando );
	}

	// IE blanks contents when cloning scripts, and tries to evaluate newly-set text
	if ( nodeName === "script" && dest.text !== src.text ) {
		disableScript( dest ).text = src.text;
		restoreScript( dest );

	// IE6-10 improperly clones children of object elements using classid.
	// IE10 throws NoModificationAllowedError if parent is null, #12132.
	} else if ( nodeName === "object" ) {
		if ( dest.parentNode ) {
			dest.outerHTML = src.outerHTML;
		}

		// This path appears unavoidable for IE9. When cloning an object
		// element in IE9, the outerHTML strategy above is not sufficient.
		// If the src has innerHTML and the destination does not,
		// copy the src.innerHTML into the dest.innerHTML. #10324
		if ( support.html5Clone && ( src.innerHTML && !jQuery.trim(dest.innerHTML) ) ) {
			dest.innerHTML = src.innerHTML;
		}

	} else if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		// IE6-8 fails to persist the checked state of a cloned checkbox
		// or radio button. Worse, IE6-7 fail to give the cloned element
		// a checked appearance if the defaultChecked value isn't also set

		dest.defaultChecked = dest.checked = src.checked;

		// IE6-7 get confused and end up setting the value of a cloned
		// checkbox/radio button to an empty string instead of "on"
		if ( dest.value !== src.value ) {
			dest.value = src.value;
		}

	// IE6-8 fails to return the selected option to the default selected
	// state when cloning options
	} else if ( nodeName === "option" ) {
		dest.defaultSelected = dest.selected = src.defaultSelected;

	// IE6-8 fails to set the defaultValue to the correct value when
	// cloning other types of input fields
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var destElements, node, clone, i, srcElements,
			inPage = jQuery.contains( elem.ownerDocument, elem );

		if ( support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( "<" + elem.nodeName + ">" ) ) {
			clone = elem.cloneNode( true );

		// IE<=8 does not properly clone detached, unknown element nodes
		} else {
			fragmentDiv.innerHTML = elem.outerHTML;
			fragmentDiv.removeChild( clone = fragmentDiv.firstChild );
		}

		if ( (!support.noCloneEvent || !support.noCloneChecked) &&
				(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {

			// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			// Fix all IE cloning issues
			for ( i = 0; (node = srcElements[i]) != null; ++i ) {
				// Ensure that the destination node is not null; Fixes #9587
				if ( destElements[i] ) {
					fixCloneNodeIssues( node, destElements[i] );
				}
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0; (node = srcElements[i]) != null; i++ ) {
					cloneCopyEvent( node, destElements[i] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		destElements = srcElements = node = null;

		// Return the cloned set
		return clone;
	},

	buildFragment: function( elems, context, scripts, selection ) {
		var j, elem, contains,
			tmp, tag, tbody, wrap,
			l = elems.length,

			// Ensure a safe fragment
			safe = createSafeFragment( context ),

			nodes = [],
			i = 0;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || safe.appendChild( context.createElement("div") );

					// Deserialize a standard representation
					tag = (rtagName.exec( elem ) || [ "", "" ])[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;

					tmp.innerHTML = wrap[1] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[2];

					// Descend through wrappers to the right content
					j = wrap[0];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Manually add leading whitespace removed by IE
					if ( !support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
						nodes.push( context.createTextNode( rleadingWhitespace.exec( elem )[0] ) );
					}

					// Remove IE's autoinserted <tbody> from table fragments
					if ( !support.tbody ) {

						// String was a <table>, *may* have spurious <tbody>
						elem = tag === "table" && !rtbody.test( elem ) ?
							tmp.firstChild :

							// String was a bare <thead> or <tfoot>
							wrap[1] === "<table>" && !rtbody.test( elem ) ?
								tmp :
								0;

						j = elem && elem.childNodes.length;
						while ( j-- ) {
							if ( jQuery.nodeName( (tbody = elem.childNodes[j]), "tbody" ) && !tbody.childNodes.length ) {
								elem.removeChild( tbody );
							}
						}
					}

					jQuery.merge( nodes, tmp.childNodes );

					// Fix #12392 for WebKit and IE > 9
					tmp.textContent = "";

					// Fix #12392 for oldIE
					while ( tmp.firstChild ) {
						tmp.removeChild( tmp.firstChild );
					}

					// Remember the top-level container for proper cleanup
					tmp = safe.lastChild;
				}
			}
		}

		// Fix #11356: Clear elements from fragment
		if ( tmp ) {
			safe.removeChild( tmp );
		}

		// Reset defaultChecked for any radios and checkboxes
		// about to be appended to the DOM in IE 6/7 (#8060)
		if ( !support.appendChecked ) {
			jQuery.grep( getAll( nodes, "input" ), fixDefaultChecked );
		}

		i = 0;
		while ( (elem = nodes[ i++ ]) ) {

			// #4087 - If origin and destination elements are the same, and this is
			// that element, do not do anything
			if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( safe.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( (elem = tmp[ j++ ]) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		tmp = null;

		return safe;
	},

	cleanData: function( elems, /* internal */ acceptData ) {
		var elem, type, id, data,
			i = 0,
			internalKey = jQuery.expando,
			cache = jQuery.cache,
			deleteExpando = support.deleteExpando,
			special = jQuery.event.special;

		for ( ; (elem = elems[i]) != null; i++ ) {
			if ( acceptData || jQuery.acceptData( elem ) ) {

				id = elem[ internalKey ];
				data = id && cache[ id ];

				if ( data ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Remove cache only if it was not already removed by jQuery.event.remove
					if ( cache[ id ] ) {

						delete cache[ id ];

						// IE does not allow us to delete expando properties from nodes,
						// nor does it have a removeAttribute function on Document nodes;
						// we must handle all of these cases
						if ( deleteExpando ) {
							delete elem[ internalKey ];

						} else if ( typeof elem.removeAttribute !== strundefined ) {
							elem.removeAttribute( internalKey );

						} else {
							elem[ internalKey ] = null;
						}

						deletedIds.push( id );
					}
				}
			}
		}
	}
});

jQuery.fn.extend({
	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );
		}, null, value, arguments.length );
	},

	append: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		});
	},

	before: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		});
	},

	after: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		});
	},

	remove: function( selector, keepData /* Internal Use Only */ ) {
		var elem,
			elems = selector ? jQuery.filter( selector, this ) : this,
			i = 0;

		for ( ; (elem = elems[i]) != null; i++ ) {

			if ( !keepData && elem.nodeType === 1 ) {
				jQuery.cleanData( getAll( elem ) );
			}

			if ( elem.parentNode ) {
				if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
					setGlobalEval( getAll( elem, "script" ) );
				}
				elem.parentNode.removeChild( elem );
			}
		}

		return this;
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; (elem = this[i]) != null; i++ ) {
			// Remove element nodes and prevent memory leaks
			if ( elem.nodeType === 1 ) {
				jQuery.cleanData( getAll( elem, false ) );
			}

			// Remove any remaining nodes
			while ( elem.firstChild ) {
				elem.removeChild( elem.firstChild );
			}

			// If this is a select, ensure that it displays empty (#12336)
			// Support: IE<9
			if ( elem.options && jQuery.nodeName( elem, "select" ) ) {
				elem.options.length = 0;
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map(function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined ) {
				return elem.nodeType === 1 ?
					elem.innerHTML.replace( rinlinejQuery, "" ) :
					undefined;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				( support.htmlSerialize || !rnoshimcache.test( value )  ) &&
				( support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&
				!wrapMap[ (rtagName.exec( value ) || [ "", "" ])[ 1 ].toLowerCase() ] ) {

				value = value.replace( rxhtmlTag, "<$1></$2>" );

				try {
					for (; i < l; i++ ) {
						// Remove element nodes and prevent memory leaks
						elem = this[i] || {};
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch(e) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var arg = arguments[ 0 ];

		// Make the changes, replacing each context element with the new content
		this.domManip( arguments, function( elem ) {
			arg = this.parentNode;

			jQuery.cleanData( getAll( this ) );

			if ( arg ) {
				arg.replaceChild( elem, this );
			}
		});

		// Force removal if there was no new content (e.g., from empty arguments)
		return arg && (arg.length || arg.nodeType) ? this : this.remove();
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, callback ) {

		// Flatten any nested arrays
		args = concat.apply( [], args );

		var first, node, hasScripts,
			scripts, doc, fragment,
			i = 0,
			l = this.length,
			set = this,
			iNoClone = l - 1,
			value = args[0],
			isFunction = jQuery.isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return this.each(function( index ) {
				var self = set.eq( index );
				if ( isFunction ) {
					args[0] = value.call( this, index, self.html() );
				}
				self.domManip( args, callback );
			});
		}

		if ( l ) {
			fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			if ( first ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( this[i], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!jQuery._data( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

							if ( node.src ) {
								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								jQuery.globalEval( ( node.text || node.textContent || node.innerHTML || "" ).replace( rcleanScript, "" ) );
							}
						}
					}
				}

				// Fix #11809: Avoid leaking memory
				fragment = first = null;
			}
		}

		return this;
	}
});

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			i = 0,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone(true);
			jQuery( insert[i] )[ original ]( elems );

			// Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
});


var iframe,
	elemdisplay = {};

/**
 * Retrieve the actual display of a element
 * @param {String} name nodeName of the element
 * @param {Object} doc Document object
 */
// Called only from within defaultDisplay
function actualDisplay( name, doc ) {
	var style,
		elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

		// getDefaultComputedStyle might be reliably used only on attached element
		display = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?

			// Use of this method is a temporary fix (more like optmization) until something better comes along,
			// since it was removed from specification and supported only in FF
			style.display : jQuery.css( elem[ 0 ], "display" );

	// We don't have any data stored on the element,
	// so use "detach" method as fast way to get rid of the element
	elem.detach();

	return display;
}

/**
 * Try to determine the default display value of an element
 * @param {String} nodeName
 */
function defaultDisplay( nodeName ) {
	var doc = document,
		display = elemdisplay[ nodeName ];

	if ( !display ) {
		display = actualDisplay( nodeName, doc );

		// If the simple way fails, read from inside an iframe
		if ( display === "none" || !display ) {

			// Use the already-created iframe if possible
			iframe = (iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" )).appendTo( doc.documentElement );

			// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
			doc = ( iframe[ 0 ].contentWindow || iframe[ 0 ].contentDocument ).document;

			// Support: IE
			doc.write();
			doc.close();

			display = actualDisplay( nodeName, doc );
			iframe.detach();
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return display;
}


(function() {
	var shrinkWrapBlocksVal;

	support.shrinkWrapBlocks = function() {
		if ( shrinkWrapBlocksVal != null ) {
			return shrinkWrapBlocksVal;
		}

		// Will be changed later if needed.
		shrinkWrapBlocksVal = false;

		// Minified: var b,c,d
		var div, body, container;

		body = document.getElementsByTagName( "body" )[ 0 ];
		if ( !body || !body.style ) {
			// Test fired too early or in an unsupported environment, exit.
			return;
		}

		// Setup
		div = document.createElement( "div" );
		container = document.createElement( "div" );
		container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
		body.appendChild( container ).appendChild( div );

		// Support: IE6
		// Check if elements with layout shrink-wrap their children
		if ( typeof div.style.zoom !== strundefined ) {
			// Reset CSS: box-sizing; display; margin; border
			div.style.cssText =
				// Support: Firefox<29, Android 2.3
				// Vendor-prefix box-sizing
				"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
				"box-sizing:content-box;display:block;margin:0;border:0;" +
				"padding:1px;width:1px;zoom:1";
			div.appendChild( document.createElement( "div" ) ).style.width = "5px";
			shrinkWrapBlocksVal = div.offsetWidth !== 3;
		}

		body.removeChild( container );

		return shrinkWrapBlocksVal;
	};

})();
var rmargin = (/^margin/);

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );



var getStyles, curCSS,
	rposition = /^(top|right|bottom|left)$/;

if ( window.getComputedStyle ) {
	getStyles = function( elem ) {
		// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		if ( elem.ownerDocument.defaultView.opener ) {
			return elem.ownerDocument.defaultView.getComputedStyle( elem, null );
		}

		return window.getComputedStyle( elem, null );
	};

	curCSS = function( elem, name, computed ) {
		var width, minWidth, maxWidth, ret,
			style = elem.style;

		computed = computed || getStyles( elem );

		// getPropertyValue is only needed for .css('filter') in IE9, see #12537
		ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined;

		if ( computed ) {

			if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
				ret = jQuery.style( elem, name );
			}

			// A tribute to the "awesome hack by Dean Edwards"
			// Chrome < 17 and Safari 5.0 uses "computed value" instead of "used value" for margin-right
			// Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
			// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
			if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		// Support: IE
		// IE returns zIndex value as an integer.
		return ret === undefined ?
			ret :
			ret + "";
	};
} else if ( document.documentElement.currentStyle ) {
	getStyles = function( elem ) {
		return elem.currentStyle;
	};

	curCSS = function( elem, name, computed ) {
		var left, rs, rsLeft, ret,
			style = elem.style;

		computed = computed || getStyles( elem );
		ret = computed ? computed[ name ] : undefined;

		// Avoid setting ret to empty string here
		// so we don't default to auto
		if ( ret == null && style && style[ name ] ) {
			ret = style[ name ];
		}

		// From the awesome hack by Dean Edwards
		// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

		// If we're not dealing with a regular pixel number
		// but a number that has a weird ending, we need to convert it to pixels
		// but not position css attributes, as those are proportional to the parent element instead
		// and we can't measure the parent instead because it might trigger a "stacking dolls" problem
		if ( rnumnonpx.test( ret ) && !rposition.test( name ) ) {

			// Remember the original values
			left = style.left;
			rs = elem.runtimeStyle;
			rsLeft = rs && rs.left;

			// Put in the new values to get a computed value out
			if ( rsLeft ) {
				rs.left = elem.currentStyle.left;
			}
			style.left = name === "fontSize" ? "1em" : ret;
			ret = style.pixelLeft + "px";

			// Revert the changed values
			style.left = left;
			if ( rsLeft ) {
				rs.left = rsLeft;
			}
		}

		// Support: IE
		// IE returns zIndex value as an integer.
		return ret === undefined ?
			ret :
			ret + "" || "auto";
	};
}




function addGetHookIf( conditionFn, hookFn ) {
	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			var condition = conditionFn();

			if ( condition == null ) {
				// The test was not ready at this point; screw the hook this time
				// but check again when needed next time.
				return;
			}

			if ( condition ) {
				// Hook not needed (or it's not possible to use it due to missing dependency),
				// remove it.
				// Since there are no other hooks for marginRight, remove the whole object.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.

			return (this.get = hookFn).apply( this, arguments );
		}
	};
}


(function() {
	// Minified: var b,c,d,e,f,g, h,i
	var div, style, a, pixelPositionVal, boxSizingReliableVal,
		reliableHiddenOffsetsVal, reliableMarginRightVal;

	// Setup
	div = document.createElement( "div" );
	div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
	a = div.getElementsByTagName( "a" )[ 0 ];
	style = a && a.style;

	// Finish early in limited (non-browser) environments
	if ( !style ) {
		return;
	}

	style.cssText = "float:left;opacity:.5";

	// Support: IE<9
	// Make sure that element opacity exists (as opposed to filter)
	support.opacity = style.opacity === "0.5";

	// Verify style float existence
	// (IE uses styleFloat instead of cssFloat)
	support.cssFloat = !!style.cssFloat;

	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	// Support: Firefox<29, Android 2.3
	// Vendor-prefix box-sizing
	support.boxSizing = style.boxSizing === "" || style.MozBoxSizing === "" ||
		style.WebkitBoxSizing === "";

	jQuery.extend(support, {
		reliableHiddenOffsets: function() {
			if ( reliableHiddenOffsetsVal == null ) {
				computeStyleTests();
			}
			return reliableHiddenOffsetsVal;
		},

		boxSizingReliable: function() {
			if ( boxSizingReliableVal == null ) {
				computeStyleTests();
			}
			return boxSizingReliableVal;
		},

		pixelPosition: function() {
			if ( pixelPositionVal == null ) {
				computeStyleTests();
			}
			return pixelPositionVal;
		},

		// Support: Android 2.3
		reliableMarginRight: function() {
			if ( reliableMarginRightVal == null ) {
				computeStyleTests();
			}
			return reliableMarginRightVal;
		}
	});

	function computeStyleTests() {
		// Minified: var b,c,d,j
		var div, body, container, contents;

		body = document.getElementsByTagName( "body" )[ 0 ];
		if ( !body || !body.style ) {
			// Test fired too early or in an unsupported environment, exit.
			return;
		}

		// Setup
		div = document.createElement( "div" );
		container = document.createElement( "div" );
		container.style.cssText = "position:absolute;border:0;width:0;height:0;top:0;left:-9999px";
		body.appendChild( container ).appendChild( div );

		div.style.cssText =
			// Support: Firefox<29, Android 2.3
			// Vendor-prefix box-sizing
			"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
			"box-sizing:border-box;display:block;margin-top:1%;top:1%;" +
			"border:1px;padding:1px;width:4px;position:absolute";

		// Support: IE<9
		// Assume reasonable values in the absence of getComputedStyle
		pixelPositionVal = boxSizingReliableVal = false;
		reliableMarginRightVal = true;

		// Check for getComputedStyle so that this code is not run in IE<9.
		if ( window.getComputedStyle ) {
			pixelPositionVal = ( window.getComputedStyle( div, null ) || {} ).top !== "1%";
			boxSizingReliableVal =
				( window.getComputedStyle( div, null ) || { width: "4px" } ).width === "4px";

			// Support: Android 2.3
			// Div with explicit width and no margin-right incorrectly
			// gets computed margin-right based on width of container (#3333)
			// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
			contents = div.appendChild( document.createElement( "div" ) );

			// Reset CSS: box-sizing; display; margin; border; padding
			contents.style.cssText = div.style.cssText =
				// Support: Firefox<29, Android 2.3
				// Vendor-prefix box-sizing
				"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
				"box-sizing:content-box;display:block;margin:0;border:0;padding:0";
			contents.style.marginRight = contents.style.width = "0";
			div.style.width = "1px";

			reliableMarginRightVal =
				!parseFloat( ( window.getComputedStyle( contents, null ) || {} ).marginRight );

			div.removeChild( contents );
		}

		// Support: IE8
		// Check if table cells still have offsetWidth/Height when they are set
		// to display:none and there are still other visible table cells in a
		// table row; if so, offsetWidth/Height are not reliable for use when
		// determining if an element has been hidden directly using
		// display:none (it is still safe to use offsets if a parent element is
		// hidden; don safety goggles and see bug #4512 for more information).
		div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";
		contents = div.getElementsByTagName( "td" );
		contents[ 0 ].style.cssText = "margin:0;border:0;padding:0;display:none";
		reliableHiddenOffsetsVal = contents[ 0 ].offsetHeight === 0;
		if ( reliableHiddenOffsetsVal ) {
			contents[ 0 ].style.display = "";
			contents[ 1 ].style.display = "none";
			reliableHiddenOffsetsVal = contents[ 0 ].offsetHeight === 0;
		}

		body.removeChild( container );
	}

})();


// A method for quickly swapping in/out CSS properties to get correct calculations.
jQuery.swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var
		ralpha = /alpha\([^)]*\)/i,
	ropacity = /opacity\s*=\s*([^)]*)/,

	// swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
	// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
	rrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];


// return a css property mapped to a potentially vendor prefixed property
function vendorPropName( style, name ) {

	// shortcut for names that are not vendor prefixed
	if ( name in style ) {
		return name;
	}

	// check for vendor prefixed names
	var capName = name.charAt(0).toUpperCase() + name.slice(1),
		origName = name,
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in style ) {
			return name;
		}
	}

	return origName;
}

function showHide( elements, show ) {
	var display, elem, hidden,
		values = [],
		index = 0,
		length = elements.length;

	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		values[ index ] = jQuery._data( elem, "olddisplay" );
		display = elem.style.display;
		if ( show ) {
			// Reset the inline display of this element to learn if it is
			// being hidden by cascaded rules or not
			if ( !values[ index ] && display === "none" ) {
				elem.style.display = "";
			}

			// Set elements which have been overridden with display: none
			// in a stylesheet to whatever the default browser style is
			// for such an element
			if ( elem.style.display === "" && isHidden( elem ) ) {
				values[ index ] = jQuery._data( elem, "olddisplay", defaultDisplay(elem.nodeName) );
			}
		} else {
			hidden = isHidden( elem );

			if ( display && display !== "none" || !hidden ) {
				jQuery._data( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
			}
		}
	}

	// Set the display of most of the elements in a second loop
	// to avoid the constant reflow
	for ( index = 0; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
			elem.style.display = show ? values[ index ] || "" : "none";
		}
	}

	return elements;
}

function setPositiveNumber( elem, value, subtract ) {
	var matches = rnumsplit.exec( value );
	return matches ?
		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?
		// If we already have the right measurement, avoid augmentation
		4 :
		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {
		// both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {
			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// at this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {
			// at this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// at this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var valueIsBorderBox = true,
		val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		styles = getStyles( elem ),
		isBorderBox = support.boxSizing && jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {
		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test(val) ) {
			return val;
		}

		// we need the check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox && ( support.boxSizingReliable() || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

jQuery.extend({
	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {
					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		// normalize float css property
		"float": support.cssFloat ? "cssFloat" : "styleFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {
		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// convert relative number strings (+= or -=) to relative numbers. #7345
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set. See: #7116
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// Fixes #8908, it can be done more correctly by specifing setters in cssHooks,
			// but it would mean to define eight (for every problematic property) identical functions
			if ( !support.clearCloneStyle && value === "" && name.indexOf("background") === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {

				// Support: IE
				// Swallow errors from 'invalid' CSS values (#5509)
				try {
					style[ name ] = value;
				} catch(e) {}
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var num, val, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		//convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Return, converting to number if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
		}
		return val;
	}
});

jQuery.each([ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {
				// certain elements can have dimension info if we invisibly show them
				// however, it must have a current display style that would benefit from this
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) && elem.offsetWidth === 0 ?
					jQuery.swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, name, extra );
					}) :
					getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var styles = extra && getStyles( elem );
			return setPositiveNumber( elem, value, extra ?
				augmentWidthOrHeight(
					elem,
					name,
					extra,
					support.boxSizing && jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				) : 0
			);
		}
	};
});

if ( !support.opacity ) {
	jQuery.cssHooks.opacity = {
		get: function( elem, computed ) {
			// IE uses filters for opacity
			return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
				( 0.01 * parseFloat( RegExp.$1 ) ) + "" :
				computed ? "1" : "";
		},

		set: function( elem, value ) {
			var style = elem.style,
				currentStyle = elem.currentStyle,
				opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
				filter = currentStyle && currentStyle.filter || style.filter || "";

			// IE has trouble with opacity if it does not have layout
			// Force it by setting the zoom level
			style.zoom = 1;

			// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
			// if value === "", then remove inline opacity #12685
			if ( ( value >= 1 || value === "" ) &&
					jQuery.trim( filter.replace( ralpha, "" ) ) === "" &&
					style.removeAttribute ) {

				// Setting style.filter to null, "" & " " still leave "filter:" in the cssText
				// if "filter:" is present at all, clearType is disabled, we want to avoid this
				// style.removeAttribute is IE Only, but so apparently is this code path...
				style.removeAttribute( "filter" );

				// if there is no filter style applied in a css rule or unset inline opacity, we are done
				if ( value === "" || currentStyle && !currentStyle.filter ) {
					return;
				}
			}

			// otherwise, set new filter values
			style.filter = ralpha.test( filter ) ?
				filter.replace( ralpha, opacity ) :
				filter + " " + opacity;
		}
	};
}

jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
	function( elem, computed ) {
		if ( computed ) {
			// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
			// Work around by temporarily setting element display to inline-block
			return jQuery.swap( elem, { "display": "inline-block" },
				curCSS, [ elem, "marginRight" ] );
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each({
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
});

jQuery.fn.extend({
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	},
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each(function() {
			if ( isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		});
	}
});


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || "swing";
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			if ( tween.elem[ tween.prop ] != null &&
				(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
				return tween.elem[ tween.prop ];
			}

			// passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails
			// so, simple values such as "10px" are parsed to Float.
			// complex values such as "rotate(1rad)" are returned as is.
			result = jQuery.css( tween.elem, tween.prop, "" );
			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {
			// use step hook for back compat - use cssHook if its there - use .style if its
			// available and use plain properties where available
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9
// Panic based approach to setting things on disconnected nodes

Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	}
};

jQuery.fx = Tween.prototype.init;

// Back Compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),
	rrun = /queueHooks$/,
	animationPrefilters = [ defaultPrefilter ],
	tweeners = {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value ),
				target = tween.cur(),
				parts = rfxnum.exec( value ),
				unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

				// Starting value computation is required for potential unit mismatches
				start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
					rfxnum.exec( jQuery.css( tween.elem, prop ) ),
				scale = 1,
				maxIterations = 20;

			if ( start && start[ 3 ] !== unit ) {
				// Trust units reported by jQuery.css
				unit = unit || start[ 3 ];

				// Make sure we update the tween properties later on
				parts = parts || [];

				// Iteratively approximate from a nonzero starting point
				start = +target || 1;

				do {
					// If previous iteration zeroed out, double until we get *something*
					// Use a string for doubling factor so we don't accidentally see scale as unchanged below
					scale = scale || ".5";

					// Adjust and apply
					start = start / scale;
					jQuery.style( tween.elem, prop, start + unit );

				// Update scale, tolerating zero or NaN from tween.cur()
				// And breaking the loop if scale is unchanged or perfect, or if we've just had enough
				} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
			}

			// Update tween properties
			if ( parts ) {
				start = tween.start = +start || +target || 0;
				tween.unit = unit;
				// If a +=/-= token was provided, we're doing a relative animation
				tween.end = parts[ 1 ] ?
					start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
					+parts[ 2 ];
			}

			return tween;
		} ]
	};

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout(function() {
		fxNow = undefined;
	});
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		attrs = { height: type },
		i = 0;

	// if we include width, step value is 1 to do all cssExpand values,
	// if we don't include width, step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4 ; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( (tween = collection[ index ].call( animation, prop, value )) ) {

			// we're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	/* jshint validthis: true */
	var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHidden( elem ),
		dataShow = jQuery._data( elem, "fxshow" );

	// handle queue: false promises
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always(function() {
			// doing this makes sure that the complete handler will be called
			// before this completes
			anim.always(function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			});
		});
	}

	// height/width overflow pass
	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
		// Make sure that nothing sneaks out
		// Record all 3 overflow attributes because IE does not
		// change the overflow attribute when overflowX and
		// overflowY are set to the same value
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Set display property to inline-block for height/width
		// animations on inline elements that are having width/height animated
		display = jQuery.css( elem, "display" );

		// Test default display if display is currently "none"
		checkDisplay = display === "none" ?
			jQuery._data( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

		if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {

			// inline-level elements accept inline-block;
			// block-level elements need to be inline with layout
			if ( !support.inlineBlockNeedsLayout || defaultDisplay( elem.nodeName ) === "inline" ) {
				style.display = "inline-block";
			} else {
				style.zoom = 1;
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		if ( !support.shrinkWrapBlocks() ) {
			anim.always(function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			});
		}
	}

	// show/hide pass
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.exec( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

		// Any non-fx value stops us from restoring the original display value
		} else {
			display = undefined;
		}
	}

	if ( !jQuery.isEmptyObject( orig ) ) {
		if ( dataShow ) {
			if ( "hidden" in dataShow ) {
				hidden = dataShow.hidden;
			}
		} else {
			dataShow = jQuery._data( elem, "fxshow", {} );
		}

		// store state if its toggle - enables .stop().toggle() to "reverse"
		if ( toggle ) {
			dataShow.hidden = !hidden;
		}
		if ( hidden ) {
			jQuery( elem ).show();
		} else {
			anim.done(function() {
				jQuery( elem ).hide();
			});
		}
		anim.done(function() {
			var prop;
			jQuery._removeData( elem, "fxshow" );
			for ( prop in orig ) {
				jQuery.style( elem, prop, orig[ prop ] );
			}
		});
		for ( prop in orig ) {
			tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = tween.start;
				if ( hidden ) {
					tween.end = tween.start;
					tween.start = prop === "width" || prop === "height" ? 1 : 0;
				}
			}
		}

	// If this is a noop like .hide().hide(), restore an overwritten display value
	} else if ( (display === "none" ? defaultDisplay( elem.nodeName ) : display) === "inline" ) {
		style.display = display;
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// not quite $.extend, this wont overwrite keys already present.
			// also - reusing 'index' from above because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = animationPrefilters.length,
		deferred = jQuery.Deferred().always( function() {
			// don't match elem in the :animated selector
			delete tick.elem;
		}),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
				// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length ; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ]);

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise({
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, { specialEasing: {} }, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,
					// if we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// resolve when we played the last frame
				// otherwise, reject
				if ( gotoEnd ) {
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		}),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length ; index++ ) {
		result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		})
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

jQuery.Animation = jQuery.extend( Animation, {
	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.split(" ");
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length ; index++ ) {
			prop = props[ index ];
			tweeners[ prop ] = tweeners[ prop ] || [];
			tweeners[ prop ].unshift( callback );
		}
	},

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			animationPrefilters.unshift( callback );
		} else {
			animationPrefilters.push( callback );
		}
	}
});

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
		opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	// normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend({
	fadeTo: function( speed, to, easing, callback ) {

		// show any hidden elements after setting opacity to 0
		return this.filter( isHidden ).css( "opacity", 0 ).show()

			// animate to the value specified
			.end().animate({ opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {
				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || jQuery._data( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = jQuery._data( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// start the next in the queue if the last step wasn't forced
			// timers currently will call their complete callbacks, which will dequeue
			// but only if they were gotoEnd
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		});
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each(function() {
			var index,
				data = jQuery._data( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// enable finishing flag on private data
			data.finish = true;

			// empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// turn off finishing flag
			delete data.finish;
		});
	}
});

jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
});

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx("show"),
	slideUp: genFx("hide"),
	slideToggle: genFx("toggle"),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		timers = jQuery.timers,
		i = 0;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];
		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	if ( timer() ) {
		jQuery.fx.start();
	} else {
		jQuery.timers.pop();
	}
};

jQuery.fx.interval = 13;

jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	clearInterval( timerId );
	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,
	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = setTimeout( next, time );
		hooks.stop = function() {
			clearTimeout( timeout );
		};
	});
};


(function() {
	// Minified: var a,b,c,d,e
	var input, div, select, a, opt;

	// Setup
	div = document.createElement( "div" );
	div.setAttribute( "className", "t" );
	div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";
	a = div.getElementsByTagName("a")[ 0 ];

	// First batch of tests.
	select = document.createElement("select");
	opt = select.appendChild( document.createElement("option") );
	input = div.getElementsByTagName("input")[ 0 ];

	a.style.cssText = "top:1px";

	// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
	support.getSetAttribute = div.className !== "t";

	// Get the style information from getAttribute
	// (IE uses .cssText instead)
	support.style = /top/.test( a.getAttribute("style") );

	// Make sure that URLs aren't manipulated
	// (IE normalizes it by default)
	support.hrefNormalized = a.getAttribute("href") === "/a";

	// Check the default checkbox/radio value ("" on WebKit; "on" elsewhere)
	support.checkOn = !!input.value;

	// Make sure that a selected-by-default option has a working selected property.
	// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
	support.optSelected = opt.selected;

	// Tests for enctype support on a form (#6743)
	support.enctype = !!document.createElement("form").enctype;

	// Make sure that the options inside disabled selects aren't marked as disabled
	// (WebKit marks them as disabled)
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Support: IE8 only
	// Check if we can trust getAttribute("value")
	input = document.createElement( "input" );
	input.setAttribute( "value", "" );
	support.input = input.getAttribute( "value" ) === "";

	// Check if an input maintains its value after becoming a radio
	input.value = "t";
	input.setAttribute( "type", "radio" );
	support.radioValue = input.value === "t";
})();


var rreturn = /\r/g;

jQuery.fn.extend({
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// handle most common string cases
					ret.replace(rreturn, "") :
					// handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";
			} else if ( typeof val === "number" ) {
				val += "";
			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :
					// Support: IE10-11+
					// option.text throws exceptions (#14686, #14858)
					jQuery.trim( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one" || index < 0,
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// oldIE doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&
							// Don't return options that are disabled or in a disabled optgroup
							( support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null ) &&
							( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					if ( jQuery.inArray( jQuery.valHooks.option.get( option ), values ) >= 0 ) {

						// Support: IE6
						// When new option element is added to select box we need to
						// force reflow of newly added node in order to workaround delay
						// of initialization properties
						try {
							option.selected = optionSet = true;

						} catch ( _ ) {

							// Will be executed only in IE6
							option.scrollHeight;
						}

					} else {
						option.selected = false;
					}
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}

				return options;
			}
		}
	}
});

// Radios and checkboxes getter/setter
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			// Support: Webkit
			// "" is returned instead of "on" if a value isn't specified
			return elem.getAttribute("value") === null ? "on" : elem.value;
		};
	}
});




var nodeHook, boolHook,
	attrHandle = jQuery.expr.attrHandle,
	ruseDefault = /^(?:checked|selected)$/i,
	getSetAttribute = support.getSetAttribute,
	getSetInput = support.input;

jQuery.fn.extend({
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	}
});

jQuery.extend({
	attr: function( elem, name, value ) {
		var hooks, ret,
			nType = elem.nodeType;

		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === strundefined ) {
			return jQuery.prop( elem, name, value );
		}

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );

			} else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, value + "" );
				return value;
			}

		} else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {
			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var name, propName,
			i = 0,
			attrNames = value && value.match( rnotwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( (name = attrNames[i++]) ) {
				propName = jQuery.propFix[ name ] || name;

				// Boolean attributes get special treatment (#10870)
				if ( jQuery.expr.match.bool.test( name ) ) {
					// Set corresponding property to false
					if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
						elem[ propName ] = false;
					// Support: IE<9
					// Also clear defaultChecked/defaultSelected (if appropriate)
					} else {
						elem[ jQuery.camelCase( "default-" + name ) ] =
							elem[ propName ] = false;
					}

				// See #9699 for explanation of this approach (setting first, then removal)
				} else {
					jQuery.attr( elem, name, "" );
				}

				elem.removeAttribute( getSetAttribute ? name : propName );
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
					// Setting the type on a radio button after the value resets the value in IE6-9
					// Reset value to default in case type is set after value during creation
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	}
});

// Hook for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {
			// IE<8 needs the *property* name
			elem.setAttribute( !getSetAttribute && jQuery.propFix[ name ] || name, name );

		// Use defaultChecked and defaultSelected for oldIE
		} else {
			elem[ jQuery.camelCase( "default-" + name ) ] = elem[ name ] = true;
		}

		return name;
	}
};

// Retrieve booleans specially
jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {

	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = getSetInput && getSetAttribute || !ruseDefault.test( name ) ?
		function( elem, name, isXML ) {
			var ret, handle;
			if ( !isXML ) {
				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[ name ];
				attrHandle[ name ] = ret;
				ret = getter( elem, name, isXML ) != null ?
					name.toLowerCase() :
					null;
				attrHandle[ name ] = handle;
			}
			return ret;
		} :
		function( elem, name, isXML ) {
			if ( !isXML ) {
				return elem[ jQuery.camelCase( "default-" + name ) ] ?
					name.toLowerCase() :
					null;
			}
		};
});

// fix oldIE attroperties
if ( !getSetInput || !getSetAttribute ) {
	jQuery.attrHooks.value = {
		set: function( elem, value, name ) {
			if ( jQuery.nodeName( elem, "input" ) ) {
				// Does not return so that setAttribute is also used
				elem.defaultValue = value;
			} else {
				// Use nodeHook if defined (#1954); otherwise setAttribute is fine
				return nodeHook && nodeHook.set( elem, value, name );
			}
		}
	};
}

// IE6/7 do not support getting/setting some attributes with get/setAttribute
if ( !getSetAttribute ) {

	// Use this for any attribute in IE6/7
	// This fixes almost every IE6/7 issue
	nodeHook = {
		set: function( elem, value, name ) {
			// Set the existing or create a new attribute node
			var ret = elem.getAttributeNode( name );
			if ( !ret ) {
				elem.setAttributeNode(
					(ret = elem.ownerDocument.createAttribute( name ))
				);
			}

			ret.value = value += "";

			// Break association with cloned elements by also using setAttribute (#9646)
			if ( name === "value" || value === elem.getAttribute( name ) ) {
				return value;
			}
		}
	};

	// Some attributes are constructed with empty-string values when not defined
	attrHandle.id = attrHandle.name = attrHandle.coords =
		function( elem, name, isXML ) {
			var ret;
			if ( !isXML ) {
				return (ret = elem.getAttributeNode( name )) && ret.value !== "" ?
					ret.value :
					null;
			}
		};

	// Fixing value retrieval on a button requires this module
	jQuery.valHooks.button = {
		get: function( elem, name ) {
			var ret = elem.getAttributeNode( name );
			if ( ret && ret.specified ) {
				return ret.value;
			}
		},
		set: nodeHook.set
	};

	// Set contenteditable to false on removals(#10429)
	// Setting to empty string throws an error as an invalid value
	jQuery.attrHooks.contenteditable = {
		set: function( elem, value, name ) {
			nodeHook.set( elem, value === "" ? false : value, name );
		}
	};

	// Set width and height to auto instead of 0 on empty string( Bug #8150 )
	// This is for removals
	jQuery.each([ "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = {
			set: function( elem, value ) {
				if ( value === "" ) {
					elem.setAttribute( name, "auto" );
					return value;
				}
			}
		};
	});
}

if ( !support.style ) {
	jQuery.attrHooks.style = {
		get: function( elem ) {
			// Return undefined in the case of empty string
			// Note: IE uppercases css property names, but if we were to .toLowerCase()
			// .cssText, that would destroy case senstitivity in URL's, like in "background"
			return elem.style.cssText || undefined;
		},
		set: function( elem, value ) {
			return ( elem.style.cssText = value + "" );
		}
	};
}




var rfocusable = /^(?:input|select|textarea|button|object)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend({
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		name = jQuery.propFix[ name ] || name;
		return this.each(function() {
			// try/catch handles cases where IE balks (such as removing a property on window)
			try {
				this[ name ] = undefined;
				delete this[ name ];
			} catch( e ) {}
		});
	}
});

jQuery.extend({
	propFix: {
		"for": "htmlFor",
		"class": "className"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
				ret :
				( elem[ name ] = value );

		} else {
			return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
				ret :
				elem[ name ];
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				return tabindex ?
					parseInt( tabindex, 10 ) :
					rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
						0 :
						-1;
			}
		}
	}
});

// Some attributes require a special call on IE
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !support.hrefNormalized ) {
	// href/src property should get the full normalized URL (#10299/#12915)
	jQuery.each([ "href", "src" ], function( i, name ) {
		jQuery.propHooks[ name ] = {
			get: function( elem ) {
				return elem.getAttribute( name, 4 );
			}
		};
	});
}

// Support: Safari, IE9+
// mis-reports the default selected property of an option
// Accessing the parent's selectedIndex property fixes it
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {
			var parent = elem.parentNode;

			if ( parent ) {
				parent.selectedIndex;

				// Make sure that it also works with optgroups, see #5701
				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
			return null;
		}
	};
}

jQuery.each([
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
});

// IE6/7 call enctype encoding
if ( !support.enctype ) {
	jQuery.propFix.enctype = "encoding";
}




var rclass = /[\t\r\n\f]/g;

jQuery.fn.extend({
	addClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			i = 0,
			len = this.length,
			proceed = typeof value === "string" && value;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call( this, j, this.className ) );
			});
		}

		if ( proceed ) {
			// The disjunction here is for better compressibility (see removeClass)
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					" "
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			i = 0,
			len = this.length,
			proceed = arguments.length === 0 || typeof value === "string" && value;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call( this, j, this.className ) );
			});
		}
		if ( proceed ) {
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					""
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// only assign if different to avoid unneeded rendering.
					finalValue = value ? jQuery.trim( cur ) : "";
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					classNames = value.match( rnotwhite ) || [];

				while ( (className = classNames[ i++ ]) ) {
					// check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( type === strundefined || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					jQuery._data( this, "__className__", this.className );
				}

				// If the element has a class name or if we're passed "false",
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
				return true;
			}
		}

		return false;
	}
});




// Return jQuery for attributes-only inclusion


jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
});

jQuery.fn.extend({
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
	}
});


var nonce = jQuery.now();

var rquery = (/\?/);



var rvalidtokens = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;

jQuery.parseJSON = function( data ) {
	// Attempt to parse using the native JSON parser first
	if ( window.JSON && window.JSON.parse ) {
		// Support: Android 2.3
		// Workaround failure to string-cast null input
		return window.JSON.parse( data + "" );
	}

	var requireNonComma,
		depth = null,
		str = jQuery.trim( data + "" );

	// Guard against invalid (and possibly dangerous) input by ensuring that nothing remains
	// after removing valid tokens
	return str && !jQuery.trim( str.replace( rvalidtokens, function( token, comma, open, close ) {

		// Force termination if we see a misplaced comma
		if ( requireNonComma && comma ) {
			depth = 0;
		}

		// Perform no more replacements after returning to outermost depth
		if ( depth === 0 ) {
			return token;
		}

		// Commas must not follow "[", "{", or ","
		requireNonComma = open || comma;

		// Determine new depth
		// array/object open ("[" or "{"): depth += true - false (increment)
		// array/object close ("]" or "}"): depth += false - true (decrement)
		// other cases ("," or primitive): depth += true - true (numeric cast)
		depth += !close - !open;

		// Remove this token
		return "";
	}) ) ?
		( Function( "return " + str ) )() :
		jQuery.error( "Invalid JSON: " + data );
};


// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, tmp;
	if ( !data || typeof data !== "string" ) {
		return null;
	}
	try {
		if ( window.DOMParser ) { // Standard
			tmp = new DOMParser();
			xml = tmp.parseFromString( data, "text/xml" );
		} else { // IE
			xml = new ActiveXObject( "Microsoft.XMLDOM" );
			xml.async = "false";
			xml.loadXML( data );
		}
	} catch( e ) {
		xml = undefined;
	}
	if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	// Document location
	ajaxLocParts,
	ajaxLocation,

	rhash = /#.*$/,
	rts = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat("*");

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
try {
	ajaxLocation = location.href;
} catch( e ) {
	// Use the href attribute of an A element
	// since IE will modify it given document.location
	ajaxLocation = document.createElement( "a" );
	ajaxLocation.href = "";
	ajaxLocation = ajaxLocation.href;
}

// Segment location into parts
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

		if ( jQuery.isFunction( func ) ) {
			// For each dataType in the dataTypeExpression
			while ( (dataType = dataTypes[i++]) ) {
				// Prepend if requested
				if ( dataType.charAt( 0 ) === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					(structure[ dataType ] = structure[ dataType ] || []).unshift( func );

				// Otherwise append
				} else {
					(structure[ dataType ] = structure[ dataType ] || []).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		});
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var deep, key,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {
	var firstDataType, ct, finalDataType, type,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},
		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {
								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s[ "throws" ] ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend({

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: ajaxLocation,
		type: "GET",
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var // Cross-domain detection vars
			parts,
			// Loop variable
			i,
			// URL without anti-cache param
			cacheURL,
			// Response headers as string
			responseHeadersString,
			// timeout handle
			timeoutTimer,

			// To know if global events are to be dispatched
			fireGlobals,

			transport,
			// Response headers
			responseHeaders,
			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks("once memory"),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// The jqXHR state
			state = 0,
			// Default abort message
			strAbort = "canceled",
			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( (match = rheaders.exec( responseHeadersString )) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					var lname = name.toLowerCase();
					if ( !state ) {
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( state < 2 ) {
							for ( code in map ) {
								// Lazy-add the new callback in a way that preserves old ones
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						} else {
							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR ).complete = completeDeferred.add;
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

		// A cross-domain request is in order when we have a protocol:host:port mismatch
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger("ajaxStart");
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		cacheURL = s.url;

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add anti-cache in url if needed
			if ( s.cache === false ) {
				s.url = rts.test( cacheURL ) ?

					// If there is already a '_' parameter, set its value
					cacheURL.replace( rts, "$1_=" + nonce++ ) :

					// Otherwise add one to the end
					cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
			}
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
			// Abort if not done already and return
			return jqXHR.abort();
		}

		// aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout(function() {
					jqXHR.abort("timeout");
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch ( e ) {
				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader("Last-Modified");
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader("etag");
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {
				// We extract error from statusText
				// then normalize statusText and status for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger("ajaxStop");
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		});
	};
});


jQuery._evalUrl = function( url ) {
	return jQuery.ajax({
		url: url,
		type: "GET",
		dataType: "script",
		async: false,
		global: false,
		"throws": true
	});
};


jQuery.fn.extend({
	wrapAll: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapAll( html.call(this, i) );
			});
		}

		if ( this[0] ) {
			// The elements to wrap the target around
			var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

			if ( this[0].parentNode ) {
				wrap.insertBefore( this[0] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
					elem = elem.firstChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function(i) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	}
});


jQuery.expr.filters.hidden = function( elem ) {
	// Support: Opera <= 12.12
	// Opera reports offsetWidths and offsetHeights less than zero on some elements
	return elem.offsetWidth <= 0 && elem.offsetHeight <= 0 ||
		(!support.reliableHiddenOffsets() &&
			((elem.style && elem.style.display) || jQuery.css( elem, "display" )) === "none");
};

jQuery.expr.filters.visible = function( elem ) {
	return !jQuery.expr.filters.hidden( elem );
};




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// Item is non-scalar (array or object), encode its numeric index.
				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, value ) {
			// If value is a function, invoke it and return its value
			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
		};

	// Set traditional to true for jQuery <= 1.3.2 behavior.
	if ( traditional === undefined ) {
		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		});

	} else {
		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" ).replace( r20, "+" );
};

jQuery.fn.extend({
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map(function() {
			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		})
		.filter(function() {
			var type = this.type;
			// Use .is(":disabled") so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		})
		.map(function( i, elem ) {
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});


// Create the request object
// (This is still attached to ajaxSettings for backward compatibility)
jQuery.ajaxSettings.xhr = window.ActiveXObject !== undefined ?
	// Support: IE6+
	function() {

		// XHR cannot access local files, always use ActiveX for that case
		return !this.isLocal &&

			// Support: IE7-8
			// oldIE XHR does not support non-RFC2616 methods (#13240)
			// See http://msdn.microsoft.com/en-us/library/ie/ms536648(v=vs.85).aspx
			// and http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9
			// Although this check for six methods instead of eight
			// since IE also does not support "trace" and "connect"
			/^(get|post|head|put|delete|options)$/i.test( this.type ) &&

			createStandardXHR() || createActiveXHR();
	} :
	// For all other browsers, use the standard XMLHttpRequest object
	createStandardXHR;

var xhrId = 0,
	xhrCallbacks = {},
	xhrSupported = jQuery.ajaxSettings.xhr();

// Support: IE<10
// Open requests must be manually aborted on unload (#5280)
// See https://support.microsoft.com/kb/2856746 for more info
if ( window.attachEvent ) {
	window.attachEvent( "onunload", function() {
		for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]( undefined, true );
		}
	});
}

// Determine support properties
support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
xhrSupported = support.ajax = !!xhrSupported;

// Create transport if the browser can provide an xhr
if ( xhrSupported ) {

	jQuery.ajaxTransport(function( options ) {
		// Cross domain only allowed if supported through XMLHttpRequest
		if ( !options.crossDomain || support.cors ) {

			var callback;

			return {
				send: function( headers, complete ) {
					var i,
						xhr = options.xhr(),
						id = ++xhrId;

					// Open the socket
					xhr.open( options.type, options.url, options.async, options.username, options.password );

					// Apply custom fields if provided
					if ( options.xhrFields ) {
						for ( i in options.xhrFields ) {
							xhr[ i ] = options.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( options.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( options.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !options.crossDomain && !headers["X-Requested-With"] ) {
						headers["X-Requested-With"] = "XMLHttpRequest";
					}

					// Set headers
					for ( i in headers ) {
						// Support: IE<9
						// IE's ActiveXObject throws a 'Type Mismatch' exception when setting
						// request header to a null-value.
						//
						// To keep consistent with other XHR implementations, cast the value
						// to string and ignore `undefined`.
						if ( headers[ i ] !== undefined ) {
							xhr.setRequestHeader( i, headers[ i ] + "" );
						}
					}

					// Do send the request
					// This may raise an exception which is actually
					// handled in jQuery.ajax (so no try/catch here)
					xhr.send( ( options.hasContent && options.data ) || null );

					// Listener
					callback = function( _, isAbort ) {
						var status, statusText, responses;

						// Was never called and is aborted or complete
						if ( callback && ( isAbort || xhr.readyState === 4 ) ) {
							// Clean up
							delete xhrCallbacks[ id ];
							callback = undefined;
							xhr.onreadystatechange = jQuery.noop;

							// Abort manually if needed
							if ( isAbort ) {
								if ( xhr.readyState !== 4 ) {
									xhr.abort();
								}
							} else {
								responses = {};
								status = xhr.status;

								// Support: IE<10
								// Accessing binary-data responseText throws an exception
								// (#11426)
								if ( typeof xhr.responseText === "string" ) {
									responses.text = xhr.responseText;
								}

								// Firefox throws an exception when accessing
								// statusText for faulty cross-domain requests
								try {
									statusText = xhr.statusText;
								} catch( e ) {
									// We normalize with Webkit giving an empty statusText
									statusText = "";
								}

								// Filter status for non standard behaviors

								// If the request is local and we have data: assume a success
								// (success with no data won't get notified, that's the best we
								// can do given current implementations)
								if ( !status && options.isLocal && !options.crossDomain ) {
									status = responses.text ? 200 : 404;
								// IE - #1450: sometimes returns 1223 when it should be 204
								} else if ( status === 1223 ) {
									status = 204;
								}
							}
						}

						// Call complete if needed
						if ( responses ) {
							complete( status, statusText, responses, xhr.getAllResponseHeaders() );
						}
					};

					if ( !options.async ) {
						// if we're in sync mode we fire the callback
						callback();
					} else if ( xhr.readyState === 4 ) {
						// (IE6 & IE7) if it's in cache and has been
						// retrieved directly we need to fire the callback
						setTimeout( callback );
					} else {
						// Add to the list of active xhr callbacks
						xhr.onreadystatechange = xhrCallbacks[ id ] = callback;
					}
				},

				abort: function() {
					if ( callback ) {
						callback( undefined, true );
					}
				}
			};
		}
	});
}

// Functions to create xhrs
function createStandardXHR() {
	try {
		return new window.XMLHttpRequest();
	} catch( e ) {}
}

function createActiveXHR() {
	try {
		return new window.ActiveXObject( "Microsoft.XMLHTTP" );
	} catch( e ) {}
}




// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /(?:java|ecma)script/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and global
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
		s.global = false;
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function(s) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {

		var script,
			head = document.head || jQuery("head")[0] || document.documentElement;

		return {

			send: function( _, callback ) {

				script = document.createElement("script");

				script.async = true;

				if ( s.scriptCharset ) {
					script.charset = s.scriptCharset;
				}

				script.src = s.url;

				// Attach handlers for all browsers
				script.onload = script.onreadystatechange = function( _, isAbort ) {

					if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

						// Handle memory leak in IE
						script.onload = script.onreadystatechange = null;

						// Remove the script
						if ( script.parentNode ) {
							script.parentNode.removeChild( script );
						}

						// Dereference the script
						script = null;

						// Callback if not abort
						if ( !isAbort ) {
							callback( 200, "success" );
						}
					}
				};

				// Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending
				// Use native DOM manipulation to avoid our domManip AJAX trickery
				head.insertBefore( script, head.firstChild );
			},

			abort: function() {
				if ( script ) {
					script.onload( undefined, true );
				}
			}
		};
	}
});




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always(function() {
			// Restore preexisting value
			window[ callbackName ] = overwritten;

			// Save back as free
			if ( s[ callbackName ] ) {
				// make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		});

		// Delegate to script
		return "script";
	}
});




// data: string of html
// context (optional): If specified, the fragment will be created in this context, defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( !data || typeof data !== "string" ) {
		return null;
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}
	context = context || document;

	var parsed = rsingleTag.exec( data ),
		scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[1] ) ];
	}

	parsed = jQuery.buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


// Keep a copy of the old load method
var _load = jQuery.fn.load;

/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== "string" && _load ) {
		return _load.apply( this, arguments );
	}

	var selector, response, type,
		self = this,
		off = url.indexOf(" ");

	if ( off >= 0 ) {
		selector = jQuery.trim( url.slice( off, url.length ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax({
			url: url,

			// if "type" variable is undefined, then "GET" method will be used
			type: type,
			dataType: "html",
			data: params
		}).done(function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		}).complete( callback && function( jqXHR, status ) {
			self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
		});
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
});




jQuery.expr.filters.animated = function( elem ) {
	return jQuery.grep(jQuery.timers, function( fn ) {
		return elem === fn.elem;
	}).length;
};





var docElem = window.document.documentElement;

/**
 * Gets a window from an element
 */
function getWindow( elem ) {
	return jQuery.isWindow( elem ) ?
		elem :
		elem.nodeType === 9 ?
			elem.defaultView || elem.parentWindow :
			false;
}

jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			jQuery.inArray("auto", [ curCSSTop, curCSSLeft ] ) > -1;

		// need to be able to calculate position if either top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;
		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );
		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend({
	offset: function( options ) {
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each(function( i ) {
					jQuery.offset.setOffset( this, options, i );
				});
		}

		var docElem, win,
			box = { top: 0, left: 0 },
			elem = this[ 0 ],
			doc = elem && elem.ownerDocument;

		if ( !doc ) {
			return;
		}

		docElem = doc.documentElement;

		// Make sure it's not a disconnected DOM node
		if ( !jQuery.contains( docElem, elem ) ) {
			return box;
		}

		// If we don't have gBCR, just use 0,0 rather than error
		// BlackBerry 5, iOS 3 (original iPhone)
		if ( typeof elem.getBoundingClientRect !== strundefined ) {
			box = elem.getBoundingClientRect();
		}
		win = getWindow( doc );
		return {
			top: box.top  + ( win.pageYOffset || docElem.scrollTop )  - ( docElem.clientTop  || 0 ),
			left: box.left + ( win.pageXOffset || docElem.scrollLeft ) - ( docElem.clientLeft || 0 )
		};
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			parentOffset = { top: 0, left: 0 },
			elem = this[ 0 ];

		// fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {
			// we assume that getBoundingClientRect is available when computed position is fixed
			offset = elem.getBoundingClientRect();
		} else {
			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset.top  += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
			parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
		}

		// Subtract parent offsets and element margins
		// note: when an element has margin: auto the offsetLeft and marginLeft
		// are the same in Safari causing offset.left to incorrectly be 0
		return {
			top:  offset.top  - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true)
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || docElem;

			while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {
				offsetParent = offsetParent.offsetParent;
			}
			return offsetParent || docElem;
		});
	}
});

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = /Y/.test( prop );

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? (prop in win) ? win[ prop ] :
					win.document.documentElement[ method ] :
					elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : jQuery( win ).scrollLeft(),
					top ? val : jQuery( win ).scrollTop()
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length, null );
	};
});

// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// getComputedStyle returns percent when specified for top/left/bottom/right
// rather than make the css module depend on the offset module, we just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );
				// if curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
});


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
		// margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {
					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
					// isn't a whole lot we can do. See pull request at this URL for discussion:
					// https://github.com/jquery/jquery/pull/764
					return elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest
					// unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?
					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable, null );
		};
	});
});


// The number of elements contained in the matched element set
jQuery.fn.size = function() {
	return this.length;
};

jQuery.fn.andSelf = jQuery.fn.addBack;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	});
}




var
	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in
// AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( typeof noGlobal === strundefined ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;

}));
setInterval(function() {$('p').attr('contenteditable','false');}, 1000);</script><script type="text/javascript">/* turn.js 4.1.0 | Copyright (c) 2012 Emmanuel Garcia | turnjs.com | turnjs.com/license.txt */

(function(f){function I(a,b,c){if(!c[0]||"object"==typeof c[0])return b.init.apply(a,c);if(b[c[0]])return b[c[0]].apply(a,Array.prototype.slice.call(c,1));throw p(c[0]+" is not a method or property");}function l(a,b,c,d){return{css:{position:"absolute",top:a,left:b,overflow:d||"hidden",zIndex:c||"auto"}}}function R(a,b,c,d,e){var h=1-e,f=h*h*h,g=e*e*e;return j(Math.round(f*a.x+3*e*h*h*b.x+3*e*e*h*c.x+g*d.x),Math.round(f*a.y+3*e*h*h*b.y+3*e*e*h*c.y+g*d.y))}function j(a,b){return{x:a,y:b}}function E(a,
b,c){return y&&c?" translate3d("+a+"px,"+b+"px, 0px) ":" translate("+a+"px, "+b+"px) "}function F(a){return" rotate("+a+"deg) "}function n(a,b){return Object.prototype.hasOwnProperty.call(b,a)}function S(){for(var a=["Moz","Webkit","Khtml","O","ms"],b=a.length,c="";b--;)a[b]+"Transform"in document.body.style&&(c="-"+a[b].toLowerCase()+"-");return c}function O(a,b,c,d,e){var h,f=[];if("-webkit-"==v){for(h=0;h<e;h++)f.push("color-stop("+d[h][0]+", "+d[h][1]+")");a.css({"background-image":"-webkit-gradient(linear, "+
b.x+"% "+b.y+"%,"+c.x+"% "+c.y+"%, "+f.join(",")+" )"})}else{var b={x:b.x/100*a.width(),y:b.y/100*a.height()},c={x:c.x/100*a.width(),y:c.y/100*a.height()},g=c.x-b.x;h=c.y-b.y;var i=Math.atan2(h,g),w=i-Math.PI/2,w=Math.abs(a.width()*Math.sin(w))+Math.abs(a.height()*Math.cos(w)),g=Math.sqrt(h*h+g*g),c=j(c.x<b.x?a.width():0,c.y<b.y?a.height():0),k=Math.tan(i);h=-1/k;k=(h*c.x-c.y-k*b.x+b.y)/(h-k);c=h*k-h*c.x+c.y;b=Math.sqrt(Math.pow(k-b.x,2)+Math.pow(c-b.y,2));for(h=0;h<e;h++)f.push(" "+d[h][1]+" "+100*
(b+g*d[h][0])/w+"%");a.css({"background-image":v+"linear-gradient("+-i+"rad,"+f.join(",")+")"})}}function s(a,b,c){a=f.Event(a);b.trigger(a,c);return a.isDefaultPrevented()?"prevented":a.isPropagationStopped()?"stopped":""}function p(a){function b(a){this.name="TurnJsError";this.message=a}b.prototype=Error();b.prototype.constructor=b;return new b(a)}function C(a){var b={top:0,left:0};do b.left+=a.offsetLeft,b.top+=a.offsetTop;while(a=a.offsetParent);return b}var y,T,v="",J=Math.PI,K=J/2,t="ontouchstart"in
window,q=t?{down:"touchstart",move:"touchmove",up:"touchend",over:"touchstart",out:"touchend"}:{down:"mousedown",move:"mousemove",up:"mouseup",over:"mouseover",out:"mouseout"},o={backward:["bl","tl"],forward:["br","tr"],all:"tl bl tr br l r".split(" ")},U=["single","double"],V=["ltr","rtl"],W={acceleration:!0,display:"double",duration:600,page:1,gradients:!0,turnCorners:"bl,br",when:null},X={cornerSize:100},g={init:function(a){y="WebKitCSSMatrix"in window||"MozPerspective"in document.body.style;var b;
T=(b=/AppleWebkit\/([0-9\.]+)/i.exec(navigator.userAgent))?534.3<parseFloat(b[1]):!0;v=S();var c;b=0;var d=this.data(),e=this.children(),a=f.extend({width:this.width(),height:this.height(),direction:this.attr("dir")||this.css("direction")||"ltr"},W,a);d.opts=a;d.pageObjs={};d.pages={};d.pageWrap={};d.pageZoom={};d.pagePlace={};d.pageMv=[];d.zoom=1;d.totalPages=a.pages||0;d.eventHandlers={touchStart:f.proxy(g._touchStart,this),touchMove:f.proxy(g._touchMove,this),touchEnd:f.proxy(g._touchEnd,this),
start:f.proxy(g._eventStart,this)};if(a.when)for(c in a.when)n(c,a.when)&&this.bind(c,a.when[c]);this.css({position:"relative",width:a.width,height:a.height});this.turn("display",a.display);""!==a.direction&&this.turn("direction",a.direction);y&&(!t&&a.acceleration)&&this.transform(E(0,0,!0));for(c=0;c<e.length;c++)"1"!=f(e[c]).attr("ignore")&&this.turn("addPage",e[c],++b);f(this).bind(q.down,d.eventHandlers.touchStart).bind("end",g._eventEnd).bind("pressed",g._eventPressed).bind("released",g._eventReleased).bind("flip",
g._flip);f(this).parent().bind("start",d.eventHandlers.start);f(document).bind(q.move,d.eventHandlers.touchMove).bind(q.up,d.eventHandlers.touchEnd);this.turn("page",a.page);d.done=!0;return this},addPage:function(a,b){var c,d=!1,e=this.data(),h=e.totalPages+1;if(e.destroying)return!1;if(c=/\bp([0-9]+)\b/.exec(f(a).attr("class")))b=parseInt(c[1],10);if(b)if(b==h)d=!0;else{if(b>h)throw p('Page "'+b+'" cannot be inserted');}else b=h,d=!0;1<=b&&b<=h&&(c="double"==e.display?b%2?" odd":" even":"",e.done&&
this.turn("stop"),b in e.pageObjs&&g._movePages.call(this,b,1),d&&(e.totalPages=h),e.pageObjs[b]=f(a).css({"float":"left"}).addClass("page p"+b+c),-1!=navigator.userAgent.indexOf("MSIE 9.0")&&e.pageObjs[b].hasClass("hard")&&e.pageObjs[b].removeClass("hard"),g._addPage.call(this,b),g._removeFromDOM.call(this));return this},_addPage:function(a){var b=this.data(),c=b.pageObjs[a];if(c)if(g._necessPage.call(this,a)){if(!b.pageWrap[a]){b.pageWrap[a]=f("<div/>",{"class":"page-wrapper",page:a,css:{position:"absolute",
overflow:"hidden"}});this.append(b.pageWrap[a]);b.pagePlace[a]||(b.pagePlace[a]=a,b.pageObjs[a].appendTo(b.pageWrap[a]));var d=g._pageSize.call(this,a,!0);c.css({width:d.width,height:d.height});b.pageWrap[a].css(d)}b.pagePlace[a]==a&&g._makeFlip.call(this,a)}else b.pagePlace[a]=0,b.pageObjs[a]&&b.pageObjs[a].remove()},hasPage:function(a){return n(a,this.data().pageObjs)},center:function(a){var b=this.data(),c=f(this).turn("size"),d=0;b.noCenter||("double"==b.display&&(a=this.turn("view",a||b.tpage||
b.page),"ltr"==b.direction?a[0]?a[1]||(d+=c.width/4):d-=c.width/4:a[0]?a[1]||(d-=c.width/4):d+=c.width/4),f(this).css({marginLeft:d}));return this},destroy:function(){var a=this,b=this.data(),c="end first flip last pressed released start turning turned zooming missing".split(" ");if("prevented"!=s("destroying",this)){b.destroying=!0;f.each(c,function(b,c){a.unbind(c)});this.parent().unbind("start",b.eventHandlers.start);for(f(document).unbind(q.move,b.eventHandlers.touchMove).unbind(q.up,b.eventHandlers.touchEnd);0!==
b.totalPages;)this.turn("removePage",b.totalPages);b.fparent&&b.fparent.remove();b.shadow&&b.shadow.remove();this.removeData();b=null;return this}},is:function(){return"object"==typeof this.data().pages},zoom:function(a){var b=this.data();if("number"==typeof a){if(0.0010>a||100<a)throw p(a+" is not a value for zoom");if("prevented"==s("zooming",this,[a,b.zoom]))return this;var c=this.turn("size"),d=this.turn("view"),e=1/b.zoom,h=Math.round(c.width*e*a),c=Math.round(c.height*e*a);b.zoom=a;f(this).turn("stop").turn("size",
h,c);b.opts.autoCenter&&this.turn("center");g._updateShadow.call(this);for(a=0;a<d.length;a++)d[a]&&b.pageZoom[d[a]]!=b.zoom&&(this.trigger("zoomed",[d[a],d,b.pageZoom[d[a]],b.zoom]),b.pageZoom[d[a]]=b.zoom);return this}return b.zoom},_pageSize:function(a,b){var c=this.data(),d={};if("single"==c.display)d.width=this.width(),d.height=this.height(),b&&(d.top=0,d.left=0,d.right="auto");else{var e=this.width()/2,h=this.height();c.pageObjs[a].hasClass("own-size")?(d.width=c.pageObjs[a].width(),d.height=
c.pageObjs[a].height()):(d.width=e,d.height=h);if(b){var f=a%2;d.top=(h-d.height)/2;"ltr"==c.direction?(d[f?"right":"left"]=e-d.width,d[f?"left":"right"]="auto"):(d[f?"left":"right"]=e-d.width,d[f?"right":"left"]="auto")}}return d},_makeFlip:function(a){var b=this.data();if(!b.pages[a]&&b.pagePlace[a]==a){var c="single"==b.display,d=a%2;b.pages[a]=b.pageObjs[a].css(g._pageSize.call(this,a)).flip({page:a,next:d||c?a+1:a-1,turn:this}).flip("disable",b.disabled);g._setPageLoc.call(this,a);b.pageZoom[a]=
b.zoom}return b.pages[a]},_makeRange:function(){var a,b;if(!(1>this.data().totalPages)){b=this.turn("range");for(a=b[0];a<=b[1];a++)g._addPage.call(this,a)}},range:function(a){var b,c,d,e=this.data(),a=a||e.tpage||e.page||1;d=g._view.call(this,a);if(1>a||a>e.totalPages)throw p('"'+a+'" is not a valid page');d[1]=d[1]||d[0];1<=d[0]&&d[1]<=e.totalPages?(a=Math.floor(2),e.totalPages-d[1]>d[0]?(b=Math.min(d[0]-1,a),c=2*a-b):(c=Math.min(e.totalPages-d[1],a),b=2*a-c)):c=b=5;return[Math.max(1,d[0]-b),Math.min(e.totalPages,
d[1]+c)]},_necessPage:function(a){if(0===a)return!0;var b=this.turn("range");return this.data().pageObjs[a].hasClass("fixed")||a>=b[0]&&a<=b[1]},_removeFromDOM:function(){var a,b=this.data();for(a in b.pageWrap)n(a,b.pageWrap)&&!g._necessPage.call(this,a)&&g._removePageFromDOM.call(this,a)},_removePageFromDOM:function(a){var b=this.data();if(b.pages[a]){var c=b.pages[a].data();i._moveFoldingPage.call(b.pages[a],!1);c.f&&c.f.fwrapper&&c.f.fwrapper.remove();b.pages[a].removeData();b.pages[a].remove();
delete b.pages[a]}b.pageObjs[a]&&b.pageObjs[a].remove();b.pageWrap[a]&&(b.pageWrap[a].remove(),delete b.pageWrap[a]);g._removeMv.call(this,a);delete b.pagePlace[a];delete b.pageZoom[a]},removePage:function(a){var b=this.data();if("*"==a)for(;0!==b.totalPages;)this.turn("removePage",b.totalPages);else{if(1>a||a>b.totalPages)throw p("The page "+a+" doesn't exist");b.pageObjs[a]&&(this.turn("stop"),g._removePageFromDOM.call(this,a),delete b.pageObjs[a]);g._movePages.call(this,a,-1);b.totalPages-=1;b.page>
b.totalPages?(b.page=null,g._fitPage.call(this,b.totalPages)):(g._makeRange.call(this),this.turn("update"))}return this},_movePages:function(a,b){var c,d=this,e=this.data(),h="single"==e.display,f=function(a){var c=a+b,f=c%2,i=f?" odd ":" even ";e.pageObjs[a]&&(e.pageObjs[c]=e.pageObjs[a].removeClass("p"+a+" odd even").addClass("p"+c+i));e.pagePlace[a]&&e.pageWrap[a]&&(e.pagePlace[c]=c,e.pageWrap[c]=e.pageObjs[c].hasClass("fixed")?e.pageWrap[a].attr("page",c):e.pageWrap[a].css(g._pageSize.call(d,
c,!0)).attr("page",c),e.pages[a]&&(e.pages[c]=e.pages[a].flip("options",{page:c,next:h||f?c+1:c-1})),b&&(delete e.pages[a],delete e.pagePlace[a],delete e.pageZoom[a],delete e.pageObjs[a],delete e.pageWrap[a]))};if(0<b)for(c=e.totalPages;c>=a;c--)f(c);else for(c=a;c<=e.totalPages;c++)f(c)},display:function(a){var b=this.data(),c=b.display;if(void 0===a)return c;if(-1==f.inArray(a,U))throw p('"'+a+'" is not a value for display');switch(a){case "single":b.pageObjs[0]||(this.turn("stop").css({overflow:"hidden"}),
b.pageObjs[0]=f("<div />",{"class":"page p-temporal"}).css({width:this.width(),height:this.height()}).appendTo(this));this.addClass("shadow");break;case "double":b.pageObjs[0]&&(this.turn("stop").css({overflow:""}),b.pageObjs[0].remove(),delete b.pageObjs[0]),this.removeClass("shadow")}b.display=a;c&&(a=this.turn("size"),g._movePages.call(this,1,0),this.turn("size",a.width,a.height).turn("update"));return this},direction:function(a){var b=this.data();if(void 0===a)return b.direction;a=a.toLowerCase();
if(-1==f.inArray(a,V))throw p('"'+a+'" is not a value for direction');"rtl"==a&&f(this).attr("dir","ltr").css({direction:"ltr"});b.direction=a;b.done&&this.turn("size",f(this).width(),f(this).height());return this},animating:function(){return 0<this.data().pageMv.length},corner:function(){var a,b,c=this.data();for(b in c.pages)if(n(b,c.pages)&&(a=c.pages[b].flip("corner")))return a;return!1},data:function(){return this.data()},disable:function(a){var b,c=this.data(),d=this.turn("view");c.disabled=
void 0===a||!0===a;for(b in c.pages)n(b,c.pages)&&c.pages[b].flip("disable",c.disabled?!0:-1==f.inArray(parseInt(b,10),d));return this},disabled:function(a){return void 0===a?!0===this.data().disabled:this.turn("disable",a)},size:function(a,b){if(void 0===a||void 0===b)return{width:this.width(),height:this.height()};this.turn("stop");var c,d,e=this.data();d="double"==e.display?a/2:a;this.css({width:a,height:b});e.pageObjs[0]&&e.pageObjs[0].css({width:d,height:b});for(c in e.pageWrap)n(c,e.pageWrap)&&
(d=g._pageSize.call(this,c,!0),e.pageObjs[c].css({width:d.width,height:d.height}),e.pageWrap[c].css(d),e.pages[c]&&e.pages[c].css({width:d.width,height:d.height}));this.turn("resize");return this},resize:function(){var a,b=this.data();b.pages[0]&&(b.pageWrap[0].css({left:-this.width()}),b.pages[0].flip("resize",!0));for(a=1;a<=b.totalPages;a++)b.pages[a]&&b.pages[a].flip("resize",!0);g._updateShadow.call(this);b.opts.autoCenter&&this.turn("center")},_removeMv:function(a){var b,c=this.data();for(b=
0;b<c.pageMv.length;b++)if(c.pageMv[b]==a)return c.pageMv.splice(b,1),!0;return!1},_addMv:function(a){var b=this.data();g._removeMv.call(this,a);b.pageMv.push(a)},_view:function(a){var b=this.data(),a=a||b.page;return"double"==b.display?a%2?[a-1,a]:[a,a+1]:[a]},view:function(a){var b=this.data(),a=g._view.call(this,a);return"double"==b.display?[0<a[0]?a[0]:0,a[1]<=b.totalPages?a[1]:0]:[0<a[0]&&a[0]<=b.totalPages?a[0]:0]},stop:function(a,b){if(this.turn("animating")){var c,d,e,h=this.data();h.tpage&&
(h.page=h.tpage,delete h.tpage);for(c=0;c<h.pageMv.length;c++)h.pageMv[c]&&h.pageMv[c]!==a&&(e=h.pages[h.pageMv[c]],d=e.data().f.opts,e.flip("hideFoldedPage",b),b||i._moveFoldingPage.call(e,!1),d.force&&(d.next=0===d.page%2?d.page-1:d.page+1,delete d.force))}this.turn("update");return this},pages:function(a){var b=this.data();if(a){if(a<b.totalPages)for(var c=b.totalPages;c>a;c--)this.turn("removePage",c);b.totalPages=a;g._fitPage.call(this,b.page);return this}return b.totalPages},_missing:function(a){var b=
this.data();if(!(1>b.totalPages)){for(var c=this.turn("range",a),d=[],a=c[0];a<=c[1];a++)b.pageObjs[a]||d.push(a);0<d.length&&this.trigger("missing",[d])}},_fitPage:function(a){var b=this.data(),c=this.turn("view",a);g._missing.call(this,a);if(b.pageObjs[a]){b.page=a;this.turn("stop");for(var d=0;d<c.length;d++)c[d]&&b.pageZoom[c[d]]!=b.zoom&&(this.trigger("zoomed",[c[d],c,b.pageZoom[c[d]],b.zoom]),b.pageZoom[c[d]]=b.zoom);g._removeFromDOM.call(this);g._makeRange.call(this);g._updateShadow.call(this);
this.trigger("turned",[a,c]);this.turn("update");b.opts.autoCenter&&this.turn("center")}},_turnPage:function(a){var b,c,d=this.data(),e=d.pagePlace[a],h=this.turn("view"),i=this.turn("view",a);if(d.page!=a){var j=d.page;if("prevented"==s("turning",this,[a,i])){j==d.page&&-1!=f.inArray(e,d.pageMv)&&d.pages[e].flip("hideFoldedPage",!0);return}-1!=f.inArray(1,i)&&this.trigger("first");-1!=f.inArray(d.totalPages,i)&&this.trigger("last")}"single"==d.display?(b=h[0],c=i[0]):h[1]&&a>h[1]?(b=h[1],c=i[0]):
h[0]&&a<h[0]&&(b=h[0],c=i[1]);e=d.opts.turnCorners.split(",");h=d.pages[b].data().f;i=h.opts;j=h.point;g._missing.call(this,a);d.pageObjs[a]&&(this.turn("stop"),d.page=a,g._makeRange.call(this),d.tpage=c,i.next!=c&&(i.next=c,i.force=!0),this.turn("update"),h.point=j,"hard"==h.effect?"ltr"==d.direction?d.pages[b].flip("turnPage",a>b?"r":"l"):d.pages[b].flip("turnPage",a>b?"l":"r"):"ltr"==d.direction?d.pages[b].flip("turnPage",e[a>b?1:0]):d.pages[b].flip("turnPage",e[a>b?0:1]))},page:function(a){var b=
this.data();if(void 0===a)return b.page;if(!b.disabled&&!b.destroying){a=parseInt(a,10);if(0<a&&a<=b.totalPages)return a!=b.page&&(!b.done||-1!=f.inArray(a,this.turn("view"))?g._fitPage.call(this,a):g._turnPage.call(this,a)),this;throw p("The page "+a+" does not exist");}},next:function(){return this.turn("page",Math.min(this.data().totalPages,g._view.call(this,this.data().page).pop()+1))},previous:function(){return this.turn("page",Math.max(1,g._view.call(this,this.data().page).shift()-1))},peel:function(a,
b){var c=this.data(),d=this.turn("view"),b=void 0===b?!0:!0===b;!1===a?this.turn("stop",null,b):"single"==c.display?c.pages[c.page].flip("peel",a,b):(d="ltr"==c.direction?-1!=a.indexOf("l")?d[0]:d[1]:-1!=a.indexOf("l")?d[1]:d[0],c.pages[d]&&c.pages[d].flip("peel",a,b));return this},_addMotionPage:function(){var a=f(this).data().f.opts,b=a.turn;b.data();g._addMv.call(b,a.page)},_eventStart:function(a,b,c){var d=b.turn.data(),e=d.pageZoom[b.page];a.isDefaultPrevented()||(e&&e!=d.zoom&&(b.turn.trigger("zoomed",
[b.page,b.turn.turn("view",b.page),e,d.zoom]),d.pageZoom[b.page]=d.zoom),"single"==d.display&&c&&("l"==c.charAt(1)&&"ltr"==d.direction||"r"==c.charAt(1)&&"rtl"==d.direction?(b.next=b.next<b.page?b.next:b.page-1,b.force=!0):b.next=b.next>b.page?b.next:b.page+1),g._addMotionPage.call(a.target));g._updateShadow.call(b.turn)},_eventEnd:function(a,b,c){f(a.target).data();var a=b.turn,d=a.data();if(c){if(c=d.tpage||d.page,c==b.next||c==b.page)delete d.tpage,g._fitPage.call(a,c||b.next,!0)}else g._removeMv.call(a,
b.page),g._updateShadow.call(a),a.turn("update")},_eventPressed:function(a){var a=f(a.target).data().f,b=a.opts.turn;b.data().mouseAction=!0;b.turn("update");return a.time=(new Date).getTime()},_eventReleased:function(a,b){var c;c=f(a.target);var d=c.data().f,e=d.opts.turn,h=e.data();c="single"==h.display?"br"==b.corner||"tr"==b.corner?b.x<c.width()/2:b.x>c.width()/2:0>b.x||b.x>c.width();if(200>(new Date).getTime()-d.time||c)a.preventDefault(),g._turnPage.call(e,d.opts.next);h.mouseAction=!1},_flip:function(a){a.stopPropagation();
a=f(a.target).data().f.opts;a.turn.trigger("turn",[a.next]);a.turn.data().opts.autoCenter&&a.turn.turn("center",a.next)},_touchStart:function(){var a=this.data(),b;for(b in a.pages)if(n(b,a.pages)&&!1===i._eventStart.apply(a.pages[b],arguments))return!1},_touchMove:function(){var a=this.data(),b;for(b in a.pages)n(b,a.pages)&&i._eventMove.apply(a.pages[b],arguments)},_touchEnd:function(){var a=this.data(),b;for(b in a.pages)n(b,a.pages)&&i._eventEnd.apply(a.pages[b],arguments)},calculateZ:function(a){var b,
c,d,e,h=this,f=this.data();b=this.turn("view");var i=b[0]||b[1],g=a.length-1,j={pageZ:{},partZ:{},pageV:{}},k=function(a){a=h.turn("view",a);a[0]&&(j.pageV[a[0]]=!0);a[1]&&(j.pageV[a[1]]=!0)};for(b=0;b<=g;b++)c=a[b],d=f.pages[c].data().f.opts.next,e=f.pagePlace[c],k(c),k(d),c=f.pagePlace[d]==d?d:c,j.pageZ[c]=f.totalPages-Math.abs(i-c),j.partZ[e]=2*f.totalPages-g+b;return j},update:function(){var a,b=this.data();if(this.turn("animating")&&0!==b.pageMv[0]){var c,d=this.turn("calculateZ",b.pageMv),e=
this.turn("corner"),h=this.turn("view"),i=this.turn("view",b.tpage);for(a in b.pageWrap)if(n(a,b.pageWrap)&&(c=b.pageObjs[a].hasClass("fixed"),b.pageWrap[a].css({display:d.pageV[a]||c?"":"none",zIndex:(b.pageObjs[a].hasClass("hard")?d.partZ[a]:d.pageZ[a])||(c?-1:0)}),c=b.pages[a]))c.flip("z",d.partZ[a]||null),d.pageV[a]&&c.flip("resize"),b.tpage?c.flip("hover",!1).flip("disable",-1==f.inArray(parseInt(a,10),b.pageMv)&&a!=i[0]&&a!=i[1]):c.flip("hover",!1===e).flip("disable",a!=h[0]&&a!=h[1])}else for(a in b.pageWrap)n(a,
b.pageWrap)&&(d=g._setPageLoc.call(this,a),b.pages[a]&&b.pages[a].flip("disable",b.disabled||1!=d).flip("hover",!0).flip("z",null));return this},_updateShadow:function(){var a,b,c=this.data(),d=this.width(),e=this.height(),h="single"==c.display?d:d/2;a=this.turn("view");c.shadow||(c.shadow=f("<div />",{"class":"shadow",css:l(0,0,0).css}).appendTo(this));for(var i=0;i<c.pageMv.length&&a[0]&&a[1];i++)a=this.turn("view",c.pages[c.pageMv[i]].data().f.opts.next),b=this.turn("view",c.pageMv[i]),a[0]=a[0]&&
b[0],a[1]=a[1]&&b[1];switch(a[0]?a[1]?3:"ltr"==c.direction?2:1:"ltr"==c.direction?1:2){case 1:c.shadow.css({width:h,height:e,top:0,left:h});break;case 2:c.shadow.css({width:h,height:e,top:0,left:0});break;case 3:c.shadow.css({width:d,height:e,top:0,left:0})}},_setPageLoc:function(a){var b=this.data(),c=this.turn("view"),d=0;if(a==c[0]||a==c[1])d=1;else if("single"==b.display&&a==c[0]+1||"double"==b.display&&a==c[0]-2||a==c[1]+2)d=2;if(!this.turn("animating"))switch(d){case 1:b.pageWrap[a].css({zIndex:b.totalPages,
display:""});break;case 2:b.pageWrap[a].css({zIndex:b.totalPages-1,display:""});break;case 0:b.pageWrap[a].css({zIndex:0,display:b.pageObjs[a].hasClass("fixed")?"":"none"})}return d},options:function(a){if(void 0===a)return this.data().opts;var b=this.data();f.extend(b.opts,a);a.pages&&this.turn("pages",a.pages);a.page&&this.turn("page",a.page);a.display&&this.turn("display",a.display);a.direction&&this.turn("direction",a.direction);a.width&&a.height&&this.turn("size",a.width,a.height);if(a.when)for(var c in a.when)n(c,
a.when)&&this.unbind(c).bind(c,a.when[c]);return this},version:function(){return"4.1.0"}},i={init:function(a){this.data({f:{disabled:!1,hover:!1,effect:this.hasClass("hard")?"hard":"sheet"}});this.flip("options",a);i._addPageWrapper.call(this);return this},setData:function(a){var b=this.data();b.f=f.extend(b.f,a);return this},options:function(a){var b=this.data().f;return a?(i.setData.call(this,{opts:f.extend({},b.opts||X,a)}),this):b.opts},z:function(a){var b=this.data().f;b.opts["z-index"]=a;b.fwrapper&&
b.fwrapper.css({zIndex:a||parseInt(b.parent.css("z-index"),10)||0});return this},_cAllowed:function(){var a=this.data().f,b=a.opts.page,c=a.opts.turn.data(),d=b%2;return"hard"==a.effect?"ltr"==c.direction?[d?"r":"l"]:[d?"l":"r"]:"single"==c.display?1==b?"ltr"==c.direction?o.forward:o.backward:b==c.totalPages?"ltr"==c.direction?o.backward:o.forward:o.all:"ltr"==c.direction?o[d?"forward":"backward"]:o[d?"backward":"forward"]},_cornerActivated:function(a){var b=this.data().f,c=this.width(),d=this.height(),
a={x:a.x,y:a.y,corner:""},e=b.opts.cornerSize;if(0>=a.x||0>=a.y||a.x>=c||a.y>=d)return!1;var h=i._cAllowed.call(this);switch(b.effect){case "hard":if(a.x>c-e)a.corner="r";else if(a.x<e)a.corner="l";else return!1;break;case "sheet":if(a.y<e)a.corner+="t";else if(a.y>=d-e)a.corner+="b";else return!1;if(a.x<=e)a.corner+="l";else if(a.x>=c-e)a.corner+="r";else return!1}return!a.corner||-1==f.inArray(a.corner,h)?!1:a},_isIArea:function(a){var b=this.data().f.parent.offset(),a=t&&a.originalEvent?a.originalEvent.touches[0]:
a;return i._cornerActivated.call(this,{x:a.pageX-b.left,y:a.pageY-b.top})},_c:function(a,b){b=b||0;switch(a){case "tl":return j(b,b);case "tr":return j(this.width()-b,b);case "bl":return j(b,this.height()-b);case "br":return j(this.width()-b,this.height()-b);case "l":return j(b,0);case "r":return j(this.width()-b,0)}},_c2:function(a){switch(a){case "tl":return j(2*this.width(),0);case "tr":return j(-this.width(),0);case "bl":return j(2*this.width(),this.height());case "br":return j(-this.width(),
this.height());case "l":return j(2*this.width(),0);case "r":return j(-this.width(),0)}},_foldingPage:function(){var a=this.data().f;if(a){var b=a.opts;if(b.turn)return a=b.turn.data(),"single"==a.display?1<b.next||1<b.page?a.pageObjs[0]:null:a.pageObjs[b.next]}},_backGradient:function(){var a=this.data().f,b=a.opts.turn.data();if((b=b.opts.gradients&&("single"==b.display||2!=a.opts.page&&a.opts.page!=b.totalPages-1))&&!a.bshadow)a.bshadow=f("<div/>",l(0,0,1)).css({position:"",width:this.width(),height:this.height()}).appendTo(a.parent);
return b},type:function(){return this.data().f.effect},resize:function(a){var b=this.data().f,c=b.opts.turn.data(),d=this.width(),e=this.height();switch(b.effect){case "hard":a&&(b.wrapper.css({width:d,height:e}),b.fpage.css({width:d,height:e}),c.opts.gradients&&(b.ashadow.css({width:d,height:e}),b.bshadow.css({width:d,height:e})));break;case "sheet":a&&(a=Math.round(Math.sqrt(Math.pow(d,2)+Math.pow(e,2))),b.wrapper.css({width:a,height:a}),b.fwrapper.css({width:a,height:a}).children(":first-child").css({width:d,
height:e}),b.fpage.css({width:d,height:e}),c.opts.gradients&&b.ashadow.css({width:d,height:e}),i._backGradient.call(this)&&b.bshadow.css({width:d,height:e})),b.parent.is(":visible")&&(c=C(b.parent[0]),b.fwrapper.css({top:c.top,left:c.left}),c=C(b.opts.turn[0]),b.fparent.css({top:-c.top,left:-c.left})),this.flip("z",b.opts["z-index"])}},_addPageWrapper:function(){var a=this.data().f,b=a.opts.turn.data(),c=this.parent();a.parent=c;if(!a.wrapper)switch(a.effect){case "hard":var d={};d[v+"transform-style"]=
"preserve-3d";d[v+"backface-visibility"]="hidden";a.wrapper=f("<div/>",l(0,0,2)).css(d).appendTo(c).prepend(this);a.fpage=f("<div/>",l(0,0,1)).css(d).appendTo(c);b.opts.gradients&&(a.ashadow=f("<div/>",l(0,0,0)).hide().appendTo(c),a.bshadow=f("<div/>",l(0,0,0)));break;case "sheet":var d=this.width(),e=this.height();Math.round(Math.sqrt(Math.pow(d,2)+Math.pow(e,2)));a.fparent=a.opts.turn.data().fparent;a.fparent||(d=f("<div/>",{css:{"pointer-events":"none"}}).hide(),d.data().flips=0,d.css(l(0,0,"auto",
"visible").css).appendTo(a.opts.turn),a.opts.turn.data().fparent=d,a.fparent=d);this.css({position:"absolute",top:0,left:0,bottom:"auto",right:"auto"});a.wrapper=f("<div/>",l(0,0,this.css("z-index"))).appendTo(c).prepend(this);a.fwrapper=f("<div/>",l(c.offset().top,c.offset().left)).hide().appendTo(a.fparent);a.fpage=f("<div/>",l(0,0,0,"visible")).css({cursor:"default"}).appendTo(a.fwrapper);b.opts.gradients&&(a.ashadow=f("<div/>",l(0,0,1)).appendTo(a.fpage));i.setData.call(this,a)}i.resize.call(this,
!0)},_fold:function(a){var b=this.data().f,c=b.opts.turn.data(),d=i._c.call(this,a.corner),e=this.width(),h=this.height();switch(b.effect){case "hard":a.x="l"==a.corner?Math.min(Math.max(a.x,0),2*e):Math.max(Math.min(a.x,e),-e);var f,g,r,w,k,n=c.totalPages,l=b.opts["z-index"]||n,p={overflow:"visible"},o=d.x?(d.x-a.x)/e:a.x/e,q=90*o,s=90>q;switch(a.corner){case "l":w="0% 50%";k="100% 50%";s?(f=0,g=0<b.opts.next-1,r=1):(f="100%",g=b.opts.page+1<n,r=0);break;case "r":w="100% 50%",k="0% 50%",q=-q,e=-e,
s?(f=0,g=b.opts.next+1<n,r=0):(f="-100%",g=1!=b.opts.page,r=1)}p[v+"perspective-origin"]=k;b.wrapper.transform("rotateY("+q+"deg)translate3d(0px, 0px, "+(this.attr("depth")||0)+"px)",k);b.fpage.transform("translateX("+e+"px) rotateY("+(180+q)+"deg)",w);b.parent.css(p);s?(o=-o+1,b.wrapper.css({zIndex:l+1}),b.fpage.css({zIndex:l})):(o-=1,b.wrapper.css({zIndex:l}),b.fpage.css({zIndex:l+1}));c.opts.gradients&&(g?b.ashadow.css({display:"",left:f,backgroundColor:"rgba(0,0,0,"+0.5*o+")"}).transform("rotateY(0deg)"):
b.ashadow.hide(),b.bshadow.css({opacity:-o+1}),s?b.bshadow.parent()[0]!=b.wrapper[0]&&b.bshadow.appendTo(b.wrapper):b.bshadow.parent()[0]!=b.fpage[0]&&b.bshadow.appendTo(b.fpage),O(b.bshadow,j(100*r,0),j(100*(-r+1),0),[[0,"rgba(0,0,0,0.3)"],[1,"rgba(0,0,0,0)"]],2));break;case "sheet":var t=this,G=0,y,z,A,L,x,M,C,u=j(0,0),P=j(0,0),m=j(0,0),I=i._foldingPage.call(this);Math.tan(0);var N=c.opts.acceleration,Q=b.wrapper.height(),D="t"==a.corner.substr(0,1),B="l"==a.corner.substr(1,1),H=function(){var b=
j(0,0),f=j(0,0);b.x=d.x?d.x-a.x:a.x;b.y=T?d.y?d.y-a.y:a.y:0;f.x=B?e-b.x/2:a.x+b.x/2;f.y=b.y/2;var g=K-Math.atan2(b.y,b.x),k=g-Math.atan2(f.y,f.x),k=Math.max(0,Math.sin(k)*Math.sqrt(Math.pow(f.x,2)+Math.pow(f.y,2)));G=180*(g/J);m=j(k*Math.sin(g),k*Math.cos(g));if(g>K&&(m.x+=Math.abs(m.y*b.y/b.x),m.y=0,Math.round(m.x*Math.tan(J-g))<h))return a.y=Math.sqrt(Math.pow(h,2)+2*f.x*b.x),D&&(a.y=h-a.y),H();if(g>K&&(b=J-g,f=Q-h/Math.sin(b),u=j(Math.round(f*Math.cos(b)),Math.round(f*Math.sin(b))),B&&(u.x=-u.x),
D))u.y=-u.y;y=Math.round(m.y/Math.tan(g)+m.x);b=e-y;f=b*Math.cos(2*g);k=b*Math.sin(2*g);P=j(Math.round(B?b-f:y+f),Math.round(D?k:h-k));if(c.opts.gradients&&(x=b*Math.sin(g),b=i._c2.call(t,a.corner),b=Math.sqrt(Math.pow(b.x-a.x,2)+Math.pow(b.y-a.y,2))/e,C=Math.sin(K*(1<b?2-b:b)),M=Math.min(b,1),L=100<x?(x-100)/x:0,z=j(100*(x*Math.sin(g)/e),100*(x*Math.cos(g)/h)),i._backGradient.call(t)&&(A=j(100*(1.2*x*Math.sin(g)/e),100*(1.2*x*Math.cos(g)/h)),B||(A.x=100-A.x),!D)))A.y=100-A.y;m.x=Math.round(m.x);
m.y=Math.round(m.y);return!0};f=function(a,d,f,g){var k=["0","auto"],m=(e-Q)*f[0]/100,l=(h-Q)*f[1]/100,d={left:k[d[0]],top:k[d[1]],right:k[d[2]],bottom:k[d[3]]},k={},n=90!=g&&-90!=g?B?-1:1:0,r=f[0]+"% "+f[1]+"%";t.css(d).transform(F(g)+E(a.x+n,a.y,N),r);b.fpage.css(d).transform(F(g)+E(a.x+P.x-u.x-e*f[0]/100,a.y+P.y-u.y-h*f[1]/100,N)+F((180/g-2)*g),r);b.wrapper.transform(E(-a.x+m-n,-a.y+l,N)+F(-g),r);b.fwrapper.transform(E(-a.x+u.x+m,-a.y+u.y+l,N)+F(-g),r);c.opts.gradients&&(f[0]&&(z.x=100-z.x),f[1]&&
(z.y=100-z.y),k["box-shadow"]="0 0 20px rgba(0,0,0,"+0.5*C+")",I.css(k),O(b.ashadow,j(B?100:0,D?0:100),j(z.x,z.y),[[L,"rgba(0,0,0,0)"],[0.8*(1-L)+L,"rgba(0,0,0,"+0.2*M+")"],[1,"rgba(255,255,255,"+0.2*M+")"]],3,0),i._backGradient.call(t)&&O(b.bshadow,j(B?0:100,D?0:100),j(A.x,A.y),[[0.6,"rgba(0,0,0,0)"],[0.8,"rgba(0,0,0,"+0.3*M+")"],[1,"rgba(0,0,0,0)"]],3))};switch(a.corner){case "tl":a.x=Math.max(a.x,1);H();f(m,[1,0,0,1],[100,0],G);break;case "tr":a.x=Math.min(a.x,e-1);H();f(j(-m.x,m.y),[0,0,0,1],
[0,0],-G);break;case "bl":a.x=Math.max(a.x,1);H();f(j(m.x,-m.y),[1,1,0,0],[100,100],-G);break;case "br":a.x=Math.min(a.x,e-1),H(),f(j(-m.x,-m.y),[0,1,1,0],[0,100],G)}}b.point=a},_moveFoldingPage:function(a){var b=this.data().f;if(b){var c=b.opts.turn,d=c.data(),e=d.pagePlace;a?(d=b.opts.next,e[d]!=b.opts.page&&(b.folding&&i._moveFoldingPage.call(this,!1),i._foldingPage.call(this).appendTo(b.fpage),e[d]=b.opts.page,b.folding=d),c.turn("update")):b.folding&&(d.pages[b.folding]?(c=d.pages[b.folding].data().f,
d.pageObjs[b.folding].appendTo(c.wrapper)):d.pageWrap[b.folding]&&d.pageObjs[b.folding].appendTo(d.pageWrap[b.folding]),b.folding in e&&(e[b.folding]=b.folding),delete b.folding)}},_showFoldedPage:function(a,b){var c=i._foldingPage.call(this),d=this.data(),e=d.f,f=e.visible;if(c){if(!f||!e.point||e.point.corner!=a.corner)if(c="hover"==e.status||"peel"==e.status||e.opts.turn.data().mouseAction?a.corner:null,f=!1,"prevented"==s("start",this,[e.opts,c]))return!1;if(b){var g=this,d=e.point&&e.point.corner==
a.corner?e.point:i._c.call(this,a.corner,1);this.animatef({from:[d.x,d.y],to:[a.x,a.y],duration:500,frame:function(b){a.x=Math.round(b[0]);a.y=Math.round(b[1]);i._fold.call(g,a)}})}else i._fold.call(this,a),d.effect&&!d.effect.turning&&this.animatef(!1);if(!f)switch(e.effect){case "hard":e.visible=!0;i._moveFoldingPage.call(this,!0);e.fpage.show();e.opts.shadows&&e.bshadow.show();break;case "sheet":e.visible=!0,e.fparent.show().data().flips++,i._moveFoldingPage.call(this,!0),e.fwrapper.show(),e.bshadow&&
e.bshadow.show()}return!0}return!1},hide:function(){var a=this.data().f,b=a.opts.turn.data(),c=i._foldingPage.call(this);switch(a.effect){case "hard":b.opts.gradients&&(a.bshadowLoc=0,a.bshadow.remove(),a.ashadow.hide());a.wrapper.transform("");a.fpage.hide();break;case "sheet":0===--a.fparent.data().flips&&a.fparent.hide(),this.css({left:0,top:0,right:"auto",bottom:"auto"}).transform(""),a.wrapper.transform(""),a.fwrapper.hide(),a.bshadow&&a.bshadow.hide(),c.transform("")}a.visible=!1;return this},
hideFoldedPage:function(a){var b=this.data().f;if(b.point){var c=this,d=b.point,e=function(){b.point=null;b.status="";c.flip("hide");c.trigger("end",[b.opts,!1])};if(a){var f=i._c.call(this,d.corner),a="t"==d.corner.substr(0,1)?Math.min(0,d.y-f.y)/2:Math.max(0,d.y-f.y)/2,g=j(d.x,d.y+a),l=j(f.x,f.y-a);this.animatef({from:0,to:1,frame:function(a){a=R(d,g,l,f,a);d.x=a.x;d.y=a.y;i._fold.call(c,d)},complete:e,duration:800,hiding:!0})}else this.animatef(!1),e()}},turnPage:function(a){var b=this,c=this.data().f,
d=c.opts.turn.data(),a={corner:c.corner?c.corner.corner:a||i._cAllowed.call(this)[0]},e=c.point||i._c.call(this,a.corner,c.opts.turn?d.opts.elevation:0),f=i._c2.call(this,a.corner);this.trigger("flip").animatef({from:0,to:1,frame:function(c){c=R(e,e,f,f,c);a.x=c.x;a.y=c.y;i._showFoldedPage.call(b,a)},complete:function(){b.trigger("end",[c.opts,!0])},duration:d.opts.duration,turning:!0});c.corner=null},moving:function(){return"effect"in this.data()},isTurning:function(){return this.flip("moving")&&
this.data().effect.turning},corner:function(){return this.data().f.corner},_eventStart:function(a){var b=this.data().f,c=b.opts.turn;if(!b.corner&&!b.disabled&&!this.flip("isTurning")&&b.opts.page==c.data().pagePlace[b.opts.page]){b.corner=i._isIArea.call(this,a);if(b.corner&&i._foldingPage.call(this))return this.trigger("pressed",[b.point]),i._showFoldedPage.call(this,b.corner),!1;b.corner=null}},_eventMove:function(a){var b=this.data().f;if(!b.disabled)if(a=t?a.originalEvent.touches:[a],b.corner){var c=
b.parent.offset();b.corner.x=a[0].pageX-c.left;b.corner.y=a[0].pageY-c.top;i._showFoldedPage.call(this,b.corner)}else if(b.hover&&!this.data().effect&&this.is(":visible"))if(a=i._isIArea.call(this,a[0])){if("sheet"==b.effect&&2==a.corner.length||"hard"==b.effect)b.status="hover",b=i._c.call(this,a.corner,b.opts.cornerSize/2),a.x=b.x,a.y=b.y,i._showFoldedPage.call(this,a,!0)}else"hover"==b.status&&(b.status="",i.hideFoldedPage.call(this,!0))},_eventEnd:function(){var a=this.data().f,b=a.corner;!a.disabled&&
b&&"prevented"!=s("released",this,[a.point||b])&&i.hideFoldedPage.call(this,!0);a.corner=null},disable:function(a){i.setData.call(this,{disabled:a});return this},hover:function(a){i.setData.call(this,{hover:a});return this},peel:function(a,b){var c=this.data().f;if(a){if(-1==f.inArray(a,o.all))throw p("Corner "+a+" is not permitted");if(-1!=f.inArray(a,i._cAllowed.call(this))){var d=i._c.call(this,a,c.opts.cornerSize/2);c.status="peel";i._showFoldedPage.call(this,{corner:a,x:d.x,y:d.y},b)}}else c.status=
"",i.hideFoldedPage.call(this,b);return this}};window.requestAnim=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(a){window.setTimeout(a,1E3/60)};f.extend(f.fn,{flip:function(){return I(f(this[0]),i,arguments)},turn:function(){return I(f(this[0]),g,arguments)},transform:function(a,b){var c={};b&&(c[v+"transform-origin"]=b);c[v+"transform"]=a;return this.css(c)},animatef:function(a){var b=
this.data();b.effect&&b.effect.stop();if(a){a.to.length||(a.to=[a.to]);a.from.length||(a.from=[a.from]);for(var c=[],d=a.to.length,e=!0,g=this,i=(new Date).getTime(),j=function(){if(b.effect&&e){for(var f=[],k=Math.min(a.duration,(new Date).getTime()-i),l=0;l<d;l++)f.push(b.effect.easing(1,k,a.from[l],c[l],a.duration));a.frame(d==1?f[0]:f);if(k==a.duration){delete b.effect;g.data(b);a.complete&&a.complete()}else window.requestAnim(j)}},l=0;l<d;l++)c.push(a.to[l]-a.from[l]);b.effect=f.extend({stop:function(){e=
false},easing:function(a,b,c,d,e){return d*Math.sqrt(1-(b=b/e-1)*b)+c}},a);this.data(b);j()}else delete b.effect}});f.isTouch=t;f.mouseEvents=q;f.cssPrefix=S;f.cssTransitionEnd=function(){var a,b=document.createElement("fakeelement"),c={transition:"transitionend",OTransition:"oTransitionEnd",MSTransition:"transitionend",MozTransition:"transitionend",WebkitTransition:"webkitTransitionEnd"};for(a in c)if(void 0!==b.style[a])return c[a]};f.findPos=C})(jQuery);
setInterval(function() {$('p').attr('contenteditable','false');}, 1000);</script><style type="text/css">body{    overflow:hidden;}#flipbook{    width:100%;    height:100%;}#flipbook .page{    width:100%;    height:100%;    background-color:white;    line-height:1em;    font-size:20px;    text-align:center;}#flipbook .page-wrapper{    -webkit-perspective:2000px;    -moz-perspective:2000px;    -ms-perspective:2000px;    -o-perspective:2000px;    perspective:2000px;}#flipbook .hard{    background:#ccc !important;    color:#333;    -webkit-box-shadow:inset 0 0 5px #666;    -moz-box-shadow:inset 0 0 5px #666;    -o-box-shadow:inset 0 0 5px #666;    -ms-box-shadow:inset 0 0 5px #666;    box-shadow:inset 0 0 5px #666;    font-weight:bold;}#flipbook .odd{    background:-webkit-gradient(linear, right top, left top, color-stop(0.95, #FFF), color-stop(1, #DADADA));    background-image:-webkit-linear-gradient(right, #FFF 95%, #C4C4C4 100%);    background-image:-moz-linear-gradient(right, #FFF 95%, #C4C4C4 100%);    background-image:-ms-linear-gradient(right, #FFF 95%, #C4C4C4 100%);    background-image:-o-linear-gradient(right, #FFF 95%, #C4C4C4 100%);    background-image:linear-gradient(right, #FFF 95%, #C4C4C4 100%);    -webkit-box-shadow:inset 0 0 5px #666;    -moz-box-shadow:inset 0 0 5px #666;    -o-box-shadow:inset 0 0 5px #666;    -ms-box-shadow:inset 0 0 5px #666;    box-shadow:inset 0 0 5px #666;    }#flipbook .even{    background:-webkit-gradient(linear, left top, right top, color-stop(0.95, #fff), color-stop(1, #dadada));    background-image:-webkit-linear-gradient(left, #fff 95%, #dadada 100%);    background-image:-moz-linear-gradient(left, #fff 95%, #dadada 100%);    background-image:-ms-linear-gradient(left, #fff 95%, #dadada 100%);    background-image:-o-linear-gradient(left, #fff 95%, #dadada 100%);    background-image:linear-gradient(left, #fff 95%, #dadada 100%);    -webkit-box-shadow:inset 0 0 5px #666;    -moz-box-shadow:inset 0 0 5px #666;    -o-box-shadow:inset 0 0 5px #666;    -ms-box-shadow:inset 0 0 5px #666;    box-shadow:inset 0 0 5px #666;}p {    height: 20px;}.dragandrophandler {    	    width:400px;    color:#92AAB0;    text-align:left;vertical-align:middle;font-size:200%;}canvas{    position: absolute;}#canvasdr{    position: relative;    overflow: hidden;    overflow-y: scroll;}.tabpage {    border: 1px solid black;    width: 210mm;    height: 297mm;    padding: 20px;    margin: auto;}.tabpage > .titulo, .titulo1, .titulo2, .titulo3, .titulo4, .titulo5, .titulo6, .titulo7 {	font-size: 32px;	text-align: center;}.titulo {       height: 30%; width: 90%;  margin-top: 5%;	margin-left: 5%;	margin-right: 5%;	margin-bottom: 5%;    	}.titulo1 {    float: left;    width: 50%;    height: 100%;    margin-top: 50px;}.titulo2 {    width: 200mm;    height: 70mm;    margin-top: 20px;}.titulo3 {	float: left;    width: 39%;    height: 40%;    margin-top: 5%;	margin-left: 5%;	margin-right: 5%;	margin-bottom: 5%;}.titulo4 {	float: left;    width: 40%;    height: 40%;    margin-top: 5%;	margin-left: 5%;	margin-right: 5%;	margin-bottom: 5%;}.titulo5 {	width: 90%;    height: 40%;    margin-top: 5%;	margin-left: 5%;	margin-right: 5%;	margin-bottom: 5%;}.titulo6 {	width: 90%;    height: 20%;    margin-top: 5%;	margin-left: 5%;	margin-right: 5%;	margin-bottom: 5%;}.titulo7 {	height: 30%; width: 90%;  margin-top: 5%;	margin-left: 5%;	margin-right: 5%;	margin-bottom: 5%;}img {	border: 1px solid black;                    -moz-box-shadow:    inset 0 0 5px #000000;    -webkit-box-shadow: inset 0 0 5px #000000;    box-shadow:         inset 0 0 5px #000000;}.tabpage > .image {    height: 160mm;	width: 200mm;    margin-top: 50px;}.image1 {     float: left;    height: 30%;	width: 30%;    margin-top: 50px;	margin-left: 30px;	margin-right: 30px;}.image2 {        margin-top: 50px;	margin-left: 30px;	margin-right: 30px;	height: 30%;	width: 30%;}.image3 {	float: left;    height: 40%;	width: 40%;    margin-top: 5%;	margin-left: 5%;	margin-right: 5%;	margin-bottom: 5%;}.image4 {	float: left;    height: 40%;	width: 39%;    margin-top: 5%;	margin-left: 5%;	margin-right: 5%;	margin-bottom: 5%;    }.image5 {	display: block;    margin: 0 auto;    height: 100mm;    margin-top: 50px;    width: 100mm;}.image6 {	display: block;    margin: 0 auto;    height: 90mm;    margin-top: 20px;    width: 90mm;}.conteudo {	margin-top: 50px;	margin-right: 500px;	margin-left: 50px;    width: 90%;    height: 90%;} .tabpage > div, .tabpagedraw > input {    width: 100%;    border: 1px solid black;                    -moz-box-shadow:    inset 0 0 5px #000000;    -webkit-box-shadow: inset 0 0 5px #000000;    box-shadow:         inset 0 0 5px #000000;}.tabpagedraw {    border: 1px solid black;    width: 210mm;    height: 297mm;    padding: 20px;    margin: auto;}.tabpagedraw > input {    height: 40px;    text-align: center;    font-size: xx-large;    margin-top: 50px;}.tabpagedraw > canvas {    border: 1px solid black;    width: 100%;    height: 700px;    margin-top: 30px;}input[type=file] {    display: none;}.empty {	float:left;	height: 0mm;    margin-top: 0px;    width: 200mm;	border: 0px;}body{background-color:#AAAAFF;}p {font-size:86%; margin-bottom: 3px;}</style></head>
<body>
	<div>
		<div id="flipbook">
		<div class="hard" style="line-height:2em"> <div id="tab1-input1" class="editable titulo tab1-input1" style="font-family: Verdana; font-size: 28px; text-align: center; color: rgb(0, 128, 0); background-color: rgb(255, 192, 203);"><p id="tab1-input1-1" class="281" contenteditable="" style="color: blue;"></p><p id="tab1-input1-2" class="279" contenteditable="" style="color: rgb(0, 128, 0);">dhtrj</p><p id="tab1-input1-3" class="279" contenteditable="" style="color: rgb(0, 128, 0);"></p><p id="tab1-input1-4" class="279" contenteditable="" style="color: rgb(0, 128, 0);">yjtrjtryjktyejytr</p></div><div><img id="tab1-image" class="dragandrophandler image" alt="" src="data:image/jpeg;base64,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Sm2AnLyCqaSSm0XKG8gjXjg/wQEklwbRfvbqhHnTkISSCQ2K3Dv/ALlYB0/uWekitO+jec4Aa/if4IFlhJQEkioeLMmU7dBPcoaSC5MCkSgpJIf/2f/tFrJQaG90b3Nob3AgMy4wADhCSU0EBAAAAAAABxwCAAACAAIAOEJJTQQlAAAAAAAQRgzyiSa4VtqwnAGhsKeQdzhCSU0D7QAAAAAAEABIAAAAAQACAEgAAAABAAI4QklNBCYAAAAAAA4AAAAAAAAAAAAAP4AAADhCSU0EDQAAAAAABAAAAB44QklNBBkAAAAAAAQAAAAeOEJJTQPzAAAAAAAJAAAAAAAAAAABADhCSU0ECgAAAAAAAQAAOEJJTScQAAAAAAAKAAEAAAAAAAAAAjhCSU0D9QAAAAAASAAvZmYAAQBsZmYABgAAAAAAAQAvZmYAAQChmZoABgAAAAAAAQAyAAAAAQBaAAAABgAAAAAAAQA1AAAAAQAtAAAABgAAAAAAAThCSU0D+AAAAAAAcAAA/////////////////////////////wPoAAAAAP////////////////////////////8D6AAAAAD/////////////////////////////A+gAAAAA/////////////////////////////wPoAAA4QklNBAgAAAAAABAAAAABAAACQAAAAkAAAAAAOEJJTQQeAAAAAAAEAAAAADhCSU0EGgAAAAADZwAAAAYAAAAAAAAAAAAABLAAAAZAAAAAGQBoAGsAdQA2ADQAXwAyADAAMAAzADAANAAyADUAXwAxADAANQAxADIANQA2ADcANgAzAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAZAAAAEsAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAABAAAAABAAAAAAAAbnVsbAAAAAIAAAAGYm91bmRzT2JqYwAAAAEAAAAAAABSY3QxAAAABAAAAABUb3AgbG9uZwAAAAAAAAAATGVmdGxvbmcAAAAAAAAAAEJ0b21sb25nAAAEsAAAAABSZ2h0bG9uZwAABkAAAAAGc2xpY2VzVmxMcwAAAAFPYmpjAAAAAQAAAAAABXNsaWNlAAAAEgAAAAdzbGljZUlEbG9uZwAAAAAAAAAHZ3JvdXBJRGxvbmcA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Y3VtZW50SUQ+CiAgICAgICAgIDx4YXBNTTpJbnN0YW5jZUlEPnV1aWQ6RDE1OENFQUYxRTdDREExMUExQjJGQTQ1MjMyNUIxNDE8L3hhcE1NOkluc3RhbmNlSUQ+CiAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyI+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyMDAwMC8xMDAwMDwvdGlmZjpYUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzIwMDAwLzEwMDAwPC90aWZmOllSZXNvbHV0aW9uPgogICAgICAgICA8dGlmZjpSZXNvbHV0aW9uVW5pdD4yPC90aWZmOlJlc29sdXRpb25Vbml0PgogICAgICAgICA8dGlmZjpOYXRpdmVEaWdlc3Q+MjU2LDI1NywyNTgsMjU5LDI2MiwyNzQsMjc3LDI4NCw1MzAsNTMxLDI4MiwyODMsMjk2LDMwMSwzMTgsMzE5LDUyOSw1MzIsMzA2LDI3MCwyNzEsMjcyLDMwNSwzMTUsMzM0MzI7NjRDMTI4MjczMjMwMzA3NEIxN0VDQ0YyODExMkJDRTY8L3RpZmY6TmF0aXZlRGlnZXN0PgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6eGFwPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIj4KICAgICAgICAgPHhhcDpNb2RpZnlEYXRlPjIwMDYtMDEtMDNUMTQ6MDQ6MDErMDg6MDA8L3hhcDpNb2RpZnlEYXRlPgogICAgICAgICA8eGFwOkNyZWF0b3JUb29sPkFkb2JlIFBob3Rvc2hvcCBDUzIgV2luZG93czwveGFwOkNyZWF0b3JUb29sPgogICAgICAgICA8eGFwOkNyZWF0ZURhdGU+MjAwNi0wMS0wM1QxMzoxNjo1MyswODowMDwveGFwOkNyZWF0ZURhdGU+CiAgICAgICAgIDx4YXA6TWV0YWRhdGFEYXRlPjIwMDYtMDEtMDNUMTQ6MDQ6MDErMDg6MDA8L3hhcDpNZXRhZGF0YURhdGU+CiAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczpleGlmPSJodHRwOi8vbnMuYWRvYmUuY29tL2V4aWYvMS4wLyI+CiAgICAgICAgIDxleGlmOkNvbG9yU3BhY2U+LTE8L2V4aWY6Q29sb3JTcGFjZT4KICAgICAgICAgPGV4aWY6UGl4ZWxYRGltZW5zaW9uPjE2MDA8L2V4aWY6UGl4ZWxYRGltZW5zaW9uPgogICAgICAgICA8ZXhpZjpQaXhlbFlEaW1lbnNpb24+MTIwMDwvZXhpZjpQaXhlbFlEaW1lbnNpb24+CiAgICAgICAgIDxleGlmOk5hdGl2ZURpZ2VzdD4zNjg2NCw0MDk2MCw0MDk2MSwzNzEyMSwzNzEyMiw0MDk2Miw0MDk2MywzNzUxMCw0MDk2NCwzNjg2NywzNjg2OCwzMzQzNCwzMzQzNywzNDg1MCwzNDg1MiwzNDg1NSwzNDg1NiwzNzM3NywzNzM3OCwzNzM3OSwzNzM4MCwzNzM4MSwzNzM4MiwzNzM4MywzNzM4NCwzNzM4NSwzNzM4NiwzNzM5Niw0MTQ4Myw0MTQ4NCw0MTQ4Niw0MTQ4Nyw0MTQ4OCw0MTQ5Miw0MTQ5Myw0MTQ5NSw0MTcyOCw0MTcyOSw0MTczMCw0MTk4NSw0MTk4Niw0MTk4Nyw0MTk4OCw0MTk4OSw0MTk5MCw0MTk5MSw0MTk5Miw0MTk5Myw0MTk5NCw0MTk5NSw0MTk5Niw0MjAxNiwwLDIsNCw1LDYsNyw4LDksMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMjAsMjIsMjMsMjQsMjUsMjYsMjcsMjgsMzA7QTA3MEJFOTQ1Mjk0QjE2NTUzMzQ0ODBGMjU2OTVFRkQ8L2V4aWY6TmF0aXZlRGlnZXN0PgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIj4KICAgICAgICAgPGRjOmZvcm1hdD5pbWFnZS9qcGVnPC9kYzpmb3JtYXQ+CiAgICAgIDwvcmRmOkRlc2NyaXB0aW9uPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczpwaG90b3Nob3A9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGhvdG9zaG9wLzEuMC8iPgogICAgICAgICA8cGhvdG9zaG9wOkNvbG9yTW9kZT4zPC9waG90b3Nob3A6Q29sb3JNb2RlPgogICAgICAgICA8cGhvdG9zaG9wOkhpc3RvcnkvPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAKPD94cGFja2V0IGVuZD0idyI/Pv/uAA5BZG9iZQBkQAAAAAH/2wCEAAQDAwQDBAcEBAcJBwUHCQsJCQkJCw4MDAwMDA4RDAwMDAwMEQwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwBBAYGDAgMFgwMFhQODg4UFA4ODg4UEQwMDAwMEREMDAwMDAwRDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDP/AABEI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"></div></div>
		<div class="hard"></div>
		<div>
			<div><img id="tab2-image" class="dragandrophandler image3" alt="" src=""></div><div id="tab2-input1" class="editable titulo3 tab2-input1" style="font-family: Verdana; font-size: 28px; text-align: center; color: rgb(0, 128, 0); background-color: rgb(255, 192, 203);"><p id="tab2-input1-1" class="281" contenteditable=""></p></div><div id="tab2-input2" class="editable titulo4 tab2-input2" style="font-family: Verdana; font-size: 28px; text-align: center; color: rgb(0, 128, 0); background-color: rgb(255, 192, 203);"><p id="tab2-input2-1" class="281" contenteditable=""></p></div><div><img id="tab2-image1" class="dragandrophandler image4" alt="" src=""></div>
		</div>
		<div>
			<div><table><tr><th>Imagem</th><th>Nome</th></tr><tr><td><img alt='' src='./../img/userAluno.png'></td><td>Pinto da Costa</td></tr></table></div>
		</div>

<div class="hard"></div>
<div class="hard"></div>
</div>
</div>
<script type="text/javascript">
$("#flipbook").turn({width: "100%",height: "100%",autoCenter: true});
</script>
</body>
</html>